/*
* generated by Xtext
*/
package at.bachmann.plc.st.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class STLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class TestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "test");
		private final Assignment cTestAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cTestTKeyword_0 = (Keyword)cTestAssignment.eContents().get(0);
		
		//test:
		//	test="t";
		public ParserRule getRule() { return rule; }

		//test="t"
		public Assignment getTestAssignment() { return cTestAssignment; }

		//"t"
		public Keyword getTestTKeyword_0() { return cTestTKeyword_0; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumeric_LiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cChar_LiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTime_LiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBit_Str_LiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cBool_LiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Constant:
		//	Numeric_Literal | Char_Literal | Time_Literal | Bit_Str_Literal | Bool_Literal;
		public ParserRule getRule() { return rule; }

		//Numeric_Literal | Char_Literal | Time_Literal | Bit_Str_Literal | Bool_Literal
		public Alternatives getAlternatives() { return cAlternatives; }

		//Numeric_Literal
		public RuleCall getNumeric_LiteralParserRuleCall_0() { return cNumeric_LiteralParserRuleCall_0; }

		//Char_Literal
		public RuleCall getChar_LiteralParserRuleCall_1() { return cChar_LiteralParserRuleCall_1; }

		//Time_Literal
		public RuleCall getTime_LiteralParserRuleCall_2() { return cTime_LiteralParserRuleCall_2; }

		//Bit_Str_Literal
		public RuleCall getBit_Str_LiteralParserRuleCall_3() { return cBit_Str_LiteralParserRuleCall_3; }

		//Bool_Literal
		public RuleCall getBool_LiteralParserRuleCall_4() { return cBool_LiteralParserRuleCall_4; }
	}

	public class Numeric_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Numeric_Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInt_LiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReal_LiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Numeric_Literal:
		//	Int_Literal | Real_Literal;
		public ParserRule getRule() { return rule; }

		//Int_Literal | Real_Literal
		public Alternatives getAlternatives() { return cAlternatives; }

		//Int_Literal
		public RuleCall getInt_LiteralParserRuleCall_0() { return cInt_LiteralParserRuleCall_0; }

		//Real_Literal
		public RuleCall getReal_LiteralParserRuleCall_1() { return cReal_LiteralParserRuleCall_1; }
	}

	public class Int_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Int_Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSigned_IntParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnsigned_IntParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Int_Literal:
		//	Signed_Int | Unsigned_Int;
		public ParserRule getRule() { return rule; }

		//Signed_Int | Unsigned_Int
		public Alternatives getAlternatives() { return cAlternatives; }

		//Signed_Int
		public RuleCall getSigned_IntParserRuleCall_0() { return cSigned_IntParserRuleCall_0; }

		//Unsigned_Int
		public RuleCall getUnsigned_IntParserRuleCall_1() { return cUnsigned_IntParserRuleCall_1; }
	}

	public class Int_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Int_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSigned_Int_Type_NameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnsigned_Int_Type_NameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Int_Type_Name:
		//	Signed_Int_Type_Name | Unsigned_Int_Type_Name;
		public ParserRule getRule() { return rule; }

		//Signed_Int_Type_Name | Unsigned_Int_Type_Name
		public Alternatives getAlternatives() { return cAlternatives; }

		//Signed_Int_Type_Name
		public RuleCall getSigned_Int_Type_NameParserRuleCall_0() { return cSigned_Int_Type_NameParserRuleCall_0; }

		//Unsigned_Int_Type_Name
		public RuleCall getUnsigned_Int_Type_NameParserRuleCall_1() { return cUnsigned_Int_Type_NameParserRuleCall_1; }
	}

	public class Unsigned_Int_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unsigned_Int_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cUSINTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cUINTKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cUDINTKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cULINTKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//Unsigned_Int_Type_Name:
		//	"USINT" | "UINT" | "UDINT" | "ULINT";
		public ParserRule getRule() { return rule; }

		//"USINT" | "UINT" | "UDINT" | "ULINT"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"USINT"
		public Keyword getUSINTKeyword_0() { return cUSINTKeyword_0; }

		//"UINT"
		public Keyword getUINTKeyword_1() { return cUINTKeyword_1; }

		//"UDINT"
		public Keyword getUDINTKeyword_2() { return cUDINTKeyword_2; }

		//"ULINT"
		public Keyword getULINTKeyword_3() { return cULINTKeyword_3; }
	}

	public class Signed_Int_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Signed_Int_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSINTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cINTKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDINTKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLINTKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//Signed_Int_Type_Name:
		//	"SINT" | "INT" | "DINT" | "LINT";
		public ParserRule getRule() { return rule; }

		//"SINT" | "INT" | "DINT" | "LINT"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"SINT"
		public Keyword getSINTKeyword_0() { return cSINTKeyword_0; }

		//"INT"
		public Keyword getINTKeyword_1() { return cINTKeyword_1; }

		//"DINT"
		public Keyword getDINTKeyword_2() { return cDINTKeyword_2; }

		//"LINT"
		public Keyword getLINTKeyword_3() { return cLINTKeyword_3; }
	}

	public class Unsigned_IntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unsigned_Int");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueUnsigned_Int_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Unsigned_Int:
		//	value=Unsigned_Int_Value;
		public ParserRule getRule() { return rule; }

		//value=Unsigned_Int_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Unsigned_Int_Value
		public RuleCall getValueUnsigned_Int_ValueParserRuleCall_0() { return cValueUnsigned_Int_ValueParserRuleCall_0; }
	}

	public class Unsigned_Int_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unsigned_Int_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnsigned_Int_Type_NameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cBIN_VALUETerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cOCT_VALUETerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cDEC_VALUETerminalRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cHEX_VALUETerminalRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		
		//Unsigned_Int_Value:
		//	Unsigned_Int_Type_Name (BIN_VALUE | OCT_VALUE | DEC_VALUE | HEX_VALUE);
		public ParserRule getRule() { return rule; }

		//Unsigned_Int_Type_Name (BIN_VALUE | OCT_VALUE | DEC_VALUE | HEX_VALUE)
		public Group getGroup() { return cGroup; }

		//Unsigned_Int_Type_Name
		public RuleCall getUnsigned_Int_Type_NameParserRuleCall_0() { return cUnsigned_Int_Type_NameParserRuleCall_0; }

		//BIN_VALUE | OCT_VALUE | DEC_VALUE | HEX_VALUE
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//BIN_VALUE
		public RuleCall getBIN_VALUETerminalRuleCall_1_0() { return cBIN_VALUETerminalRuleCall_1_0; }

		//OCT_VALUE
		public RuleCall getOCT_VALUETerminalRuleCall_1_1() { return cOCT_VALUETerminalRuleCall_1_1; }

		//DEC_VALUE
		public RuleCall getDEC_VALUETerminalRuleCall_1_2() { return cDEC_VALUETerminalRuleCall_1_2; }

		//HEX_VALUE
		public RuleCall getHEX_VALUETerminalRuleCall_1_3() { return cHEX_VALUETerminalRuleCall_1_3; }
	}

	public class Signed_IntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Signed_Int");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSigned_Int_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Signed_Int:
		//	value=Signed_Int_Value;
		public ParserRule getRule() { return rule; }

		//value=Signed_Int_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Signed_Int_Value
		public RuleCall getValueSigned_Int_ValueParserRuleCall_0() { return cValueSigned_Int_ValueParserRuleCall_0; }
	}

	public class Signed_Int_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Signed_Int_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSigned_Int_Type_NameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cBIN_VALUETerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cOCT_VALUETerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Alternatives cAlternatives_1_2_0 = (Alternatives)cGroup_1_2.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_2_0_0 = (Keyword)cAlternatives_1_2_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_2_0_1 = (Keyword)cAlternatives_1_2_0.eContents().get(1);
		private final RuleCall cDEC_VALUETerminalRuleCall_1_2_1 = (RuleCall)cGroup_1_2.eContents().get(1);
		private final RuleCall cHEX_VALUETerminalRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		
		//Signed_Int_Value:
		//	Signed_Int_Type_Name (BIN_VALUE | OCT_VALUE | ("+" | "-")? DEC_VALUE | HEX_VALUE);
		public ParserRule getRule() { return rule; }

		//Signed_Int_Type_Name (BIN_VALUE | OCT_VALUE | ("+" | "-")? DEC_VALUE | HEX_VALUE)
		public Group getGroup() { return cGroup; }

		//Signed_Int_Type_Name
		public RuleCall getSigned_Int_Type_NameParserRuleCall_0() { return cSigned_Int_Type_NameParserRuleCall_0; }

		//BIN_VALUE | OCT_VALUE | ("+" | "-")? DEC_VALUE | HEX_VALUE
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//BIN_VALUE
		public RuleCall getBIN_VALUETerminalRuleCall_1_0() { return cBIN_VALUETerminalRuleCall_1_0; }

		//OCT_VALUE
		public RuleCall getOCT_VALUETerminalRuleCall_1_1() { return cOCT_VALUETerminalRuleCall_1_1; }

		//("+" | "-")? DEC_VALUE
		public Group getGroup_1_2() { return cGroup_1_2; }

		//("+" | "-")?
		public Alternatives getAlternatives_1_2_0() { return cAlternatives_1_2_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_2_0_0() { return cPlusSignKeyword_1_2_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_2_0_1() { return cHyphenMinusKeyword_1_2_0_1; }

		//DEC_VALUE
		public RuleCall getDEC_VALUETerminalRuleCall_1_2_1() { return cDEC_VALUETerminalRuleCall_1_2_1; }

		//HEX_VALUE
		public RuleCall getHEX_VALUETerminalRuleCall_1_3() { return cHEX_VALUETerminalRuleCall_1_3; }
	}

	public class Real_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Real_Literal");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueReal_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Real_Literal:
		//	value=Real_Value;
		public ParserRule getRule() { return rule; }

		//value=Real_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Real_Value
		public RuleCall getValueReal_ValueParserRuleCall_0() { return cValueReal_ValueParserRuleCall_0; }
	}

	public class Real_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Real_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLREALKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cREALKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Real_Type_Name:
		//	"LREAL" | "REAL";
		public ParserRule getRule() { return rule; }

		//"LREAL" | "REAL"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"LREAL"
		public Keyword getLREALKeyword_0() { return cLREALKeyword_0; }

		//"REAL"
		public Keyword getREALKeyword_1() { return cREALKeyword_1; }
	}

	public class Real_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Real_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cReal_Type_NameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final RuleCall cFLOAT_VALUETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Real_Value:
		//	Real_Type_Name ("+" | "-")? FLOAT_VALUE;
		public ParserRule getRule() { return rule; }

		//Real_Type_Name ("+" | "-")? FLOAT_VALUE
		public Group getGroup() { return cGroup; }

		//Real_Type_Name
		public RuleCall getReal_Type_NameParserRuleCall_0() { return cReal_Type_NameParserRuleCall_0; }

		//("+" | "-")?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }

		//FLOAT_VALUE
		public RuleCall getFLOAT_VALUETerminalRuleCall_2() { return cFLOAT_VALUETerminalRuleCall_2; }
	}

	public class Bit_Str_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bit_Str_Literal");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBit_Str_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Bit_Str_Literal:
		//	value=Bit_Str_Value;
		public ParserRule getRule() { return rule; }

		//value=Bit_Str_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Bit_Str_Value
		public RuleCall getValueBit_Str_ValueParserRuleCall_0() { return cValueBit_Str_ValueParserRuleCall_0; }
	}

	public class Multibits_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multibits_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBYTEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cWORDKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDWORDKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLWORDKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//Multibits_Type_Name:
		//	"BYTE" | "WORD" | "DWORD" | "LWORD";
		public ParserRule getRule() { return rule; }

		//"BYTE" | "WORD" | "DWORD" | "LWORD"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"BYTE"
		public Keyword getBYTEKeyword_0() { return cBYTEKeyword_0; }

		//"WORD"
		public Keyword getWORDKeyword_1() { return cWORDKeyword_1; }

		//"DWORD"
		public Keyword getDWORDKeyword_2() { return cDWORDKeyword_2; }

		//"LWORD"
		public Keyword getLWORDKeyword_3() { return cLWORDKeyword_3; }
	}

	public class Bit_Str_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bit_Str_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultibits_Type_NameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cBIN_VALUETerminalRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cOCT_VALUETerminalRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		private final RuleCall cDEC_VALUETerminalRuleCall_2_2 = (RuleCall)cAlternatives_2.eContents().get(2);
		private final RuleCall cHEX_VALUETerminalRuleCall_2_3 = (RuleCall)cAlternatives_2.eContents().get(3);
		
		//Bit_Str_Value:
		//	Multibits_Type_Name "#" (BIN_VALUE | OCT_VALUE | DEC_VALUE | HEX_VALUE);
		public ParserRule getRule() { return rule; }

		//Multibits_Type_Name "#" (BIN_VALUE | OCT_VALUE | DEC_VALUE | HEX_VALUE)
		public Group getGroup() { return cGroup; }

		//Multibits_Type_Name
		public RuleCall getMultibits_Type_NameParserRuleCall_0() { return cMultibits_Type_NameParserRuleCall_0; }

		//"#"
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }

		//BIN_VALUE | OCT_VALUE | DEC_VALUE | HEX_VALUE
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//BIN_VALUE
		public RuleCall getBIN_VALUETerminalRuleCall_2_0() { return cBIN_VALUETerminalRuleCall_2_0; }

		//OCT_VALUE
		public RuleCall getOCT_VALUETerminalRuleCall_2_1() { return cOCT_VALUETerminalRuleCall_2_1; }

		//DEC_VALUE
		public RuleCall getDEC_VALUETerminalRuleCall_2_2() { return cDEC_VALUETerminalRuleCall_2_2; }

		//HEX_VALUE
		public RuleCall getHEX_VALUETerminalRuleCall_2_3() { return cHEX_VALUETerminalRuleCall_2_3; }
	}

	public class Bool_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bool_Literal");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBool_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Bool_Literal:
		//	value=Bool_Value;
		public ParserRule getRule() { return rule; }

		//value=Bool_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Bool_Value
		public RuleCall getValueBool_ValueParserRuleCall_0() { return cValueBool_ValueParserRuleCall_0; }
	}

	public class Bool_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bool_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cBool_Type_NameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cNumberSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cDigitZeroKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cDigitOneKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cFALSEKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Keyword cTRUEKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		
		//Bool_Value:
		//	(Bool_Type_Name "#")? ("0" | "1" | "FALSE" | "TRUE");
		public ParserRule getRule() { return rule; }

		//(Bool_Type_Name "#")? ("0" | "1" | "FALSE" | "TRUE")
		public Group getGroup() { return cGroup; }

		//(Bool_Type_Name "#")?
		public Group getGroup_0() { return cGroup_0; }

		//Bool_Type_Name
		public RuleCall getBool_Type_NameParserRuleCall_0_0() { return cBool_Type_NameParserRuleCall_0_0; }

		//"#"
		public Keyword getNumberSignKeyword_0_1() { return cNumberSignKeyword_0_1; }

		//"0" | "1" | "FALSE" | "TRUE"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"0"
		public Keyword getDigitZeroKeyword_1_0() { return cDigitZeroKeyword_1_0; }

		//"1"
		public Keyword getDigitOneKeyword_1_1() { return cDigitOneKeyword_1_1; }

		//"FALSE"
		public Keyword getFALSEKeyword_1_2() { return cFALSEKeyword_1_2; }

		//"TRUE"
		public Keyword getTRUEKeyword_1_3() { return cTRUEKeyword_1_3; }
	}

	public class Bool_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bool_Type_Name");
		private final Keyword cBOOLKeyword = (Keyword)rule.eContents().get(1);
		
		//Bool_Type_Name:
		//	"BOOL";
		public ParserRule getRule() { return rule; }

		//"BOOL"
		public Keyword getBOOLKeyword() { return cBOOLKeyword; }
	}

	public class Char_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Char_Literal");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueChar_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// Table 6 - Character String literals
		//// Table 7 - Two-character combinations in character strings
		//Char_Literal:
		//	value=Char_Value;
		public ParserRule getRule() { return rule; }

		//value=Char_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Char_Value
		public RuleCall getValueChar_ValueParserRuleCall_0() { return cValueChar_ValueParserRuleCall_0; }
	}

	public class Char_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Char_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSTRINGKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cChar_StrParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Char_Value:
		//	"STRING#"? Char_Str;
		public ParserRule getRule() { return rule; }

		//"STRING#"? Char_Str
		public Group getGroup() { return cGroup; }

		//"STRING#"?
		public Keyword getSTRINGKeyword_0() { return cSTRINGKeyword_0; }

		//Char_Str
		public RuleCall getChar_StrParserRuleCall_1() { return cChar_StrParserRuleCall_1; }
	}

	public class Char_StrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Char_Str");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cS_Byte_Char_StrParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cD_Byte_Char_StrParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Char_Str:
		//	S_Byte_Char_Str | D_Byte_Char_Str;
		public ParserRule getRule() { return rule; }

		//S_Byte_Char_Str | D_Byte_Char_Str
		public Alternatives getAlternatives() { return cAlternatives; }

		//S_Byte_Char_Str
		public RuleCall getS_Byte_Char_StrParserRuleCall_0() { return cS_Byte_Char_StrParserRuleCall_0; }

		//D_Byte_Char_Str
		public RuleCall getD_Byte_Char_StrParserRuleCall_1() { return cD_Byte_Char_StrParserRuleCall_1; }
	}

	public class S_Byte_Char_StrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "S_Byte_Char_Str");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cApostropheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cS_BYTE_CHAR_VALUETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cApostropheKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//S_Byte_Char_Str:
		//	"\'" S_BYTE_CHAR_VALUE+ "\'";
		public ParserRule getRule() { return rule; }

		//"\'" S_BYTE_CHAR_VALUE+ "\'"
		public Group getGroup() { return cGroup; }

		//"\'"
		public Keyword getApostropheKeyword_0() { return cApostropheKeyword_0; }

		//S_BYTE_CHAR_VALUE+
		public RuleCall getS_BYTE_CHAR_VALUETerminalRuleCall_1() { return cS_BYTE_CHAR_VALUETerminalRuleCall_1; }

		//"\'"
		public Keyword getApostropheKeyword_2() { return cApostropheKeyword_2; }
	}

	public class D_Byte_Char_StrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "D_Byte_Char_Str");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuotationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cD_BYTE_CHAR_VALUETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cQuotationMarkKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//D_Byte_Char_Str:
		//	"\"" D_BYTE_CHAR_VALUE+ "\"";
		public ParserRule getRule() { return rule; }

		//"\"" D_BYTE_CHAR_VALUE+ "\""
		public Group getGroup() { return cGroup; }

		//"\""
		public Keyword getQuotationMarkKeyword_0() { return cQuotationMarkKeyword_0; }

		//D_BYTE_CHAR_VALUE+
		public RuleCall getD_BYTE_CHAR_VALUETerminalRuleCall_1() { return cD_BYTE_CHAR_VALUETerminalRuleCall_1; }

		//"\""
		public Keyword getQuotationMarkKeyword_2() { return cQuotationMarkKeyword_2; }
	}

	public class Time_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Time_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTIMEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLTIMEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//// Table 8 - Duration literals
		//// Table 9 – Date and time of day literals
		//Time_Type_Name:
		//	"TIME" | "LTIME";
		public ParserRule getRule() { return rule; }

		//"TIME" | "LTIME"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"TIME"
		public Keyword getTIMEKeyword_0() { return cTIMEKeyword_0; }

		//"LTIME"
		public Keyword getLTIMEKeyword_1() { return cLTIMEKeyword_1; }
	}

	public class Tod_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Tod_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTIME_OF_DAYKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTODKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLTODKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//Tod_Type_Name:
		//	"TIME_OF_DAY" | "TOD" | "LTOD";
		public ParserRule getRule() { return rule; }

		//"TIME_OF_DAY" | "TOD" | "LTOD"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"TIME_OF_DAY"
		public Keyword getTIME_OF_DAYKeyword_0() { return cTIME_OF_DAYKeyword_0; }

		//"TOD"
		public Keyword getTODKeyword_1() { return cTODKeyword_1; }

		//"LTOD"
		public Keyword getLTODKeyword_2() { return cLTODKeyword_2; }
	}

	public class Date_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Date_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDATEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLDATEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Date_Type_Name:
		//	"DATE" | "LDATE";
		public ParserRule getRule() { return rule; }

		//"DATE" | "LDATE"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"DATE"
		public Keyword getDATEKeyword_0() { return cDATEKeyword_0; }

		//"LDATE"
		public Keyword getLDATEKeyword_1() { return cLDATEKeyword_1; }
	}

	public class Dt_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Dt_Type_Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDATE_AND_TIMEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cDTKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLDTKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//Dt_Type_Name:
		//	"DATE_AND_TIME" | "DT" | "LDT";
		public ParserRule getRule() { return rule; }

		//"DATE_AND_TIME" | "DT" | "LDT"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"DATE_AND_TIME"
		public Keyword getDATE_AND_TIMEKeyword_0() { return cDATE_AND_TIMEKeyword_0; }

		//"DT"
		public Keyword getDTKeyword_1() { return cDTKeyword_1; }

		//"LDT"
		public Keyword getLDTKeyword_2() { return cLDTKeyword_2; }
	}

	public class Time_LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Time_Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDurationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTime_Of_DayParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDateParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDate_And_TimeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Time_Literal:
		//	Duration | Time_Of_Day | Date | Date_And_Time;
		public ParserRule getRule() { return rule; }

		//Duration | Time_Of_Day | Date | Date_And_Time
		public Alternatives getAlternatives() { return cAlternatives; }

		//Duration
		public RuleCall getDurationParserRuleCall_0() { return cDurationParserRuleCall_0; }

		//Time_Of_Day
		public RuleCall getTime_Of_DayParserRuleCall_1() { return cTime_Of_DayParserRuleCall_1; }

		//Date
		public RuleCall getDateParserRuleCall_2() { return cDateParserRuleCall_2; }

		//Date_And_Time
		public RuleCall getDate_And_TimeParserRuleCall_3() { return cDate_And_TimeParserRuleCall_3; }
	}

	public class DurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Duration");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDuration_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Duration:
		//	value=Duration_Value;
		public ParserRule getRule() { return rule; }

		//value=Duration_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Duration_Value
		public RuleCall getValueDuration_ValueParserRuleCall_0() { return cValueDuration_ValueParserRuleCall_0; }
	}

	public class Duration_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Duration_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cTime_Type_NameParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final Keyword cTKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cLTKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cPlusSignKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final RuleCall cINTERVALTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//Duration_Value:
		//	(Time_Type_Name | "T" | "LT") "#" ("+" | "-")? INTERVAL;
		public ParserRule getRule() { return rule; }

		//(Time_Type_Name | "T" | "LT") "#" ("+" | "-")? INTERVAL
		public Group getGroup() { return cGroup; }

		//Time_Type_Name | "T" | "LT"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//Time_Type_Name
		public RuleCall getTime_Type_NameParserRuleCall_0_0() { return cTime_Type_NameParserRuleCall_0_0; }

		//"T"
		public Keyword getTKeyword_0_1() { return cTKeyword_0_1; }

		//"LT"
		public Keyword getLTKeyword_0_2() { return cLTKeyword_0_2; }

		//"#"
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }

		//("+" | "-")?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"+"
		public Keyword getPlusSignKeyword_2_0() { return cPlusSignKeyword_2_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_2_1() { return cHyphenMinusKeyword_2_1; }

		//INTERVAL
		public RuleCall getINTERVALTerminalRuleCall_3() { return cINTERVALTerminalRuleCall_3; }
	}

	public class Time_Of_DayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Time_Of_Day");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueTime_Of_Day_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Time_Of_Day:
		//	value=Time_Of_Day_Value;
		public ParserRule getRule() { return rule; }

		//value=Time_Of_Day_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Time_Of_Day_Value
		public RuleCall getValueTime_Of_Day_ValueParserRuleCall_0() { return cValueTime_Of_Day_ValueParserRuleCall_0; }
	}

	public class Time_Of_Day_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Time_Of_Day_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cTod_Type_NameParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final Keyword cLTIME_OF_DAYKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDAYTIME_VALUETerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Time_Of_Day_Value:
		//	(Tod_Type_Name | "LTIME_OF_DAY") "#" DAYTIME_VALUE;
		public ParserRule getRule() { return rule; }

		//(Tod_Type_Name | "LTIME_OF_DAY") "#" DAYTIME_VALUE
		public Group getGroup() { return cGroup; }

		//Tod_Type_Name | "LTIME_OF_DAY"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//Tod_Type_Name
		public RuleCall getTod_Type_NameParserRuleCall_0_0() { return cTod_Type_NameParserRuleCall_0_0; }

		//"LTIME_OF_DAY"
		public Keyword getLTIME_OF_DAYKeyword_0_1() { return cLTIME_OF_DAYKeyword_0_1; }

		//"#"
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }

		//DAYTIME_VALUE
		public RuleCall getDAYTIME_VALUETerminalRuleCall_2() { return cDAYTIME_VALUETerminalRuleCall_2; }
	}

	public class DaytimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Daytime");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDAYTIME_VALUETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Daytime:
		//	value=DAYTIME_VALUE;
		public ParserRule getRule() { return rule; }

		//value=DAYTIME_VALUE
		public Assignment getValueAssignment() { return cValueAssignment; }

		//DAYTIME_VALUE
		public RuleCall getValueDAYTIME_VALUETerminalRuleCall_0() { return cValueDAYTIME_VALUETerminalRuleCall_0; }
	}

	public class DateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Date");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDATE_VALUETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Date:
		//	value=DATE_VALUE;
		public ParserRule getRule() { return rule; }

		//value=DATE_VALUE
		public Assignment getValueAssignment() { return cValueAssignment; }

		//DATE_VALUE
		public RuleCall getValueDATE_VALUETerminalRuleCall_0() { return cValueDATE_VALUETerminalRuleCall_0; }
	}

	public class Date_And_TimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Date_And_Time");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueDate_And_Time_ValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Date_And_Time:
		//	value=Date_And_Time_Value;
		public ParserRule getRule() { return rule; }

		//value=Date_And_Time_Value
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Date_And_Time_Value
		public RuleCall getValueDate_And_Time_ValueParserRuleCall_0() { return cValueDate_And_Time_ValueParserRuleCall_0; }
	}

	public class Date_And_Time_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Date_And_Time_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cDATE_AND_TIMEKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cLDATE_AND_TIMEKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cDTKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final Keyword cLDTKeyword_0_3 = (Keyword)cAlternatives_0.eContents().get(3);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDATE_LITERALTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cDAYTIME_VALUETerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		////// Table 10 - Elementary data types
		////Data_Type_Access : Elem_Type_Name | Derived_Type_Access;
		////Elem_Type_Name : Numeric_Type_Name | 
		////	Bit_Str_Type_Name | 
		////	String_Type_Name | 
		////	Date_Type_Name | 
		////	Time_Type_Name
		////;
		////Numeric_Type_Name : Int_Type_Name | 
		////	Real_Type_Name
		////;
		////Int_Type_Name : Sign_Int_Type_Name | 
		////	Unsign_Int_Type_Name
		////;
		////Sign_Int_Type_Name : 'SINT' | 
		////	'INT' | 
		////	'DINT' | 
		////	'LINT';
		////Unsign_Int_Type_Name : 'USINT' | 
		////	'UINT' | 
		////	'UDINT' | 
		////	'ULINT';
		////Real_Type_Name : 'LREAL' | 
		////	'REAL';
		////SString_Type_Name : 'STRING' ( '[' Unsigned_Int ']' )?;
		////WString_Type_Name : 'WSTRING' ( '[' Unsigned_Int ']' )?;
		////String_Type_Name : SString_Type_Name | 
		////	WString_Type_Name | 
		////	'CHAR' | 
		////	'WCHAR';
		////Bit_Str_Type_Name : Bool_Type_Name | 
		////	Multibits_Type_Name
		////;
		////Bool_Type_Name : 'BOOL';
		////Multibits_Type_Name : 'BYTE' | 
		////	'WORD' | 
		////	'DWORD' | 
		////	'LWORD';
		////
		////
		////// Table 11 - Declaration of user-defined data types and initialization
		////Derived_Type_Access : Qualified_Name | 
		////	String_Type_Access
		////;
		////String_Type_Access : Qualified_Prefix String_Type_Name;
		////Qualified_Prefix : ( IDENTIFIER Dot )+ ;
		////Qualified_Name : (Qualified_Prefix IDENTIFIER) | IDENTIFIER;
		////This_Qualified_Name : 'THIS' Dot Qualified_Name;
		////Data_Type_Decl : 'TYPE' ( typeDeclarations+=Type_Decl ';' )+ 'END_TYPE';
		////Struct_Decl :'STRUCT' (overlap?='OVERLAP')? ( elements+=Struct_Elem_Decl ';' )+ 'END_STRUCT';
		////Type_Decl : Simple_Type_Decl | Subrange_Type_Decl | Enum_Type_Decl | Array_Type_Decl | Struct_Type_Decl | Str_Type_Decl | Ref_Type_Decl;
		////Simple_Type_Decl : type=IDENTIFIER ':' initialization=Simple_Spec_Init;
		////Subrange_Type_Decl : type=IDENTIFIER ':' initialization=Subrange_Spec_Init;
		////Enum_Type_Decl : type=IDENTIFIER ':' initialization=( Elem_Named_Spec | Enum_Spec_Init );
		////Array_Type_Decl : type=IDENTIFIER ':' initialization=Array_Spec_Init;
		////Struct_Type_Decl : type=IDENTIFIER ':' initialization=Struct_Spec;
		////Struct_Elem_Decl : type=IDENTIFIER ( location=Located_At access=Multibit_Part_Access ? )? ':' initialization=( Simple_Spec_Init | Subrange_Spec_Init | Enum_Spec_Init | Array_Spec_Init | Struct_Spec_Init );
		////Str_Type_Decl : type=String_Type_Name ':' initialization=String_Type_Name ( ASSIGNMENT initialValue=Char_Str )?;
		////
		////Simple_Spec : type=(Elem_Type_Name | Qualified_Name);
		////Subrange_Spec : (type=Int_Type_Name '(' range=Subrange ')') | (refRange=Qualified_Name);
		////Enum_Value_Spec : type=IDENTIFIER ( ASSIGNMENT ( initialValue=Int_Literal | initialization=Constant_Expr ) )?;
		////Elem_Named_Spec : type=Elem_Type_Name ? initialization=Named_Spec_Init;
		////Array_Spec : type=(Qualified_Name | 'ARRAY') '[' ranges+=Subrange ( ',' ranges+=Subrange )* ']' 'OF' refDataType=Data_Type_Access;
		////Struct_Spec : Struct_Decl | Struct_Spec_Init;
		////Simple_Spec_Init : type=Simple_Spec ( ASSIGNMENT initialValue=Constant_Expr )?;
		////Subrange_Spec_Init : type=Subrange_Spec ( ASSIGNMENT initialValue=Signed_Int )?;
		////Subrange : lowBound=Constant_Expr '..' upBound=Constant_Expr;
		////Named_Spec_Init : '(' initialValues+=Enum_Value_Spec ( ',' initialValues+=Enum_Value_Spec )* ')' ( ASSIGNMENT value=Enum_Value )?;
		////
		////Enum_Spec_Init : type=( Enum_Item | Enum_Items | Qualified_Name ) ( ASSIGNMENT value=Enum_Value)?;
		////Enum_Item : '(' IDENTIFIER ')';
		////Enum_Items : '(' IDENTIFIER ( ','  IDENTIFIER )+ ')' ;
		////Enum_Value : value=(Enum_Qualified_Id | IDENTIFIER);
		////Enum_Qualified_Id : Qualified_Name '#' IDENTIFIER;
		////Array_Spec_Init : type=Array_Spec ( ASSIGNMENT initialValue=Array_Init )?;
		////Array_Init : '[' initialValues+=Array_Elem_Init ( ',' initialValues+=Array_Elem_Init )* ']';
		////Array_Elem_Init : (initialization=Array_Elem_Init_Value | initialValue=Unsigned_Int) '(' bound=Array_Elem_Init_Value ? ')';
		////Array_Elem_Init_Value : Constant_Expr | Enum_Value | Struct_Init | Array_Init;
		////
		////Struct_Spec_Init : type=Qualified_Name ( ASSIGNMENT initialValue=Struct_Init )?;
		////Struct_Init : '(' elementInits+=Struct_Elem_Init ( ',' elementInits+=Struct_Elem_Init )* ')';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: uncomment Constant_Expr below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Struct_Elem_Init : type=IDENTIFIER ASSIGNMENT initialization=( / * Constant_Expr | * / Enum_Value | Array_Init | Ref_Value | Struct_Init );
		////
		////
		////// Table 16 - Directly represented variables
		////Direct_Variable : '%' locationPrefix=( 'I' | 'Q' | 'M' ) sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' )? bitIndexes+=Unsigned_Int ( Dot bitIndexes+=Unsigned_Int )*;
		////
		////
		////// Table 12 - Reference operations
		////Ref_Type_Decl : type=IDENTIFIER ':' initialization=Ref_Spec_Init;
		////Ref_Spec_Init : type=Ref_Spec ( ASSIGNMENT initialValue=Ref_Value )?;
		////Ref_Spec : 'REF_TO' + reference=Data_Type_Access;
		////Ref_Value : {Ref_Value} (reference=Ref_Addr | 'NULL');
		////Ref_Addr : 'REF' '(' ( referencedVar=Symbolic_Variable | referencedName=(FB_Instance_Name | Class_Instance_Name ) ) ')';
		////Ref_Assign : type=IDENTIFIER ASSIGNMENT ( initialValue=IDENTIFIER | initialization=(Ref_Deref | Ref_Value) );
		////Ref_Deref : name= IDENTIFIER '^'+;
		////
		////
		////// Table 13 - Declaration of variables/Table 14 – Initialization of variables
		////Variable : Direct_Variable | Symbolic_Variable;
		////Symbolic_Variable : name=This_Qualified_Name variable=( Var_Access | Multi_Elem_Var );
		////Var_Access : {Var_Access} (variable=IDENTIFIER | reference=Ref_Deref);
		////Multi_Elem_Var : access=Var_Access elements+=( Subscript_List | Struct_Variable )+;
		////Subscript_List : '[' item+=Subscript ( ',' item+=Subscript )* ']';
		////Subscript : Expression;
		////Struct_Variable : Dot Struct_Elem_Select;
		////Struct_Elem_Select : Var_Access;
		////Input_Decls : {Input_Decls} 'VAR_INPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( inputs+=Input_Decl ';' )* 'END_VAR';
		////Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
		////Edge_Decl : variables=Variable_List ':' Bool_Type_Name edgeType=( 'R_EDGE' | 'F_EDGE' );
		////Var_Decl_Init : variables=Variable_List ':' initialization=(( Simple_Spec_Init | Str_Var_Decl | Ref_Spec_Init ) | Array_Var_Decl_Init | Struct_Var_Decl_Init | FB_Decl_Init | Interface_Spec_Init);
		////Ref_Var_Decl : variables=Variable_List ':' initialization=Ref_Spec;
		////Interface_Var_Decl : variables=Variable_List ':' initialization=Qualified_Name;
		////Variable_List : variables+=IDENTIFIER ( ',' variables+=IDENTIFIER )*;
		////Array_Var_Decl_Init : variables=Variable_List ':' initialization=Array_Spec_Init;
		////Array_Conformand : 'ARRAY' '[' '*' ( ',' '*' )* ']' 'OF' dataType=Data_Type_Access;
		////Array_Conform_Decl : variables=Variable_List ':' conformand=Array_Conformand;
		////Struct_Var_Decl_Init : variables=Variable_List ':' initialization=Struct_Spec_Init;
		////FB_Decl_No_Init : (names+=IDENTIFIER ( ',' names+=IDENTIFIER )*) ':' type=FB_Type_Access;
		////FB_Decl_Init : fb=FB_Decl_No_Init ( ASSIGNMENT initialization=Struct_Init )?;
		////FB_Instance_Name : Qualified_Name '^'*;
		////Output_Decls : {Output_Decls} 'VAR_OUTPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( outputs+=Output_Decl ';' )* 
		////	'END_VAR';
		////Output_Decl : Var_Decl_Init | Array_Conform_Decl;
		////In_Out_Decls : {In_Out_Decls} 'VAR_IN_OUT' ( inouts+=In_Out_Var_Decl ';' )* 
		////	'END_VAR';
		////In_Out_Var_Decl : Var_Decl | Array_Conform_Decl | FB_Decl_No_Init;
		////Var_Decl : variables=Variable_List ':' initialization=( Simple_Spec | Str_Var_Decl | Array_Var_Decl | Struct_Var_Decl );
		////Array_Var_Decl : variables=Variable_List ':' initialization=Array_Spec;
		////Struct_Var_Decl : variables=Variable_List ':' initialization=Qualified_Name;
		////Var_Decls : {Var_Decls} 'VAR' (constant?='CONSTANT' ?) access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////Retain_Var_Decls : {Retain_Var_Decls} 'VAR' 'RETAIN' access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////Loc_Var_Decls : {Loc_Var_Decls} 'VAR' modifier=( 'CONSTANT' | 'RETAIN' | 'NON_RETAIN' )? ( variables+=Loc_Var_Decl ';' )* 'END_VAR';
		////Loc_Var_Decl : name=IDENTIFIER ? location=Located_At ':' initialization=Loc_Var_Spec_Init;
		////Temp_Var_Decls : {Temp_Var_Decls} 'VAR_TEMP' ( variables+=( Var_Decl | Ref_Var_Decl | Interface_Var_Decl ) ';' )* 'END_VAR';
		////External_Var_Decls : {External_Var_Decls} 'VAR_EXTERNAL' (constant?='Constant' ?) ( variables+=External_Decl ';' )* 'END_VAR';
		////External_Decl : name=IDENTIFIER ':' ( initialization=(Simple_Spec | Array_Spec) | type=(Qualified_Name | FB_Type_Access | Qualified_Name ));
		////Global_Var_Decls : {Global_Var_Decls} 'VAR_GLOBAL' modifier=( 'CONSTANT' | 'RETAIN' )? ( variables+=Global_Var_Decl ';' )* 'END_VAR';
		////Global_Var_Decl : name=Global_Var_Spec ':' ( initialization=Loc_Var_Spec_Init | type=FB_Type_Access );
		////Global_Var_Spec : ( variables+=IDENTIFIER ( ',' variables+=IDENTIFIER )* ) | ( variables+=IDENTIFIER location=Located_At );
		////Loc_Var_Spec_Init : Simple_Spec_Init | Array_Spec_Init | Struct_Spec_Init | S_Byte_Str_Spec | D_Byte_Str_Spec;
		////Located_At : 'AT' Direct_Variable;
		////Str_Var_Decl : S_Byte_Str_Var_Decl | D_Byte_Str_Var_Decl;
		////S_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=S_Byte_Str_Spec;
		////S_Byte_Str_Spec : {S_Byte_Str_Spec} 'STRING' ( '[' bound=Unsigned_Int ']' )? ( ASSIGNMENT initialValue=S_Byte_Char_Str )?;
		////D_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=D_Byte_Str_Spec;
		////D_Byte_Str_Spec : {D_Byte_Str_Spec} 'WSTRING' ( '[' bound=Unsigned_Int ']' )? ( ASSIGNMENT initialValue=D_Byte_Char_Str )?;
		////Loc_Partly_Var_Decl : {Loc_Partly_Var_Decl} 'VAR' modifier=( 'RETAIN' | 'NON_RETAIN' )? variables+=Loc_Partly_Var * 'END_VAR';
		////Loc_Partly_Var : name=IDENTIFIER 'AT' '%' locationPrefix=( 'I' | 'Q' | 'M' ) '*' ':' initialization=Var_Spec ';';
		////Var_Spec : Simple_Spec | Array_Spec | Qualified_Name | StringVar_Spec;
		////StringVar_Spec: type=( 'STRING' | 'WSTRING' ) ( '[' bound=Unsigned_Int ']' )?;
		////
		////// Table 19 - Function declaration
		////Func_Name : Std_Func_Name | IDENTIFIER;
		////Std_Func_Name : 'TRUNC' | 'ABS' | 'SQRT' | 'LN' | 'LOG' | 'EXP' | 
		////	'SIN' | 'COS' | 'TAN' | 'ASIN' | 'ACOS' | 'ATAN' | 'ATAN2 ' | 
		////	'ADD' | 'SUB' | 'MUL' | 'DIV' | 'MOD' | 'EXPT' | 'MOVE ' | 
		////	'SHL' | 'SHR' | 'ROL' | 'ROR' | 'AND' | 'OR'  | 'XOR' | 'NOT' | 
		////	'SEL' | 'MAX' | 'MIN' | 'LIMIT' | 'MUX ' | 'GT' | 'GE' | 'EQ' | 
		////	'LE' | 'LT' | 'NE' | 'LEN' | 'LEFT' | 'RIGHT' | 'MID' | 'CONCAT' | 
		////	'INSERT' | 'DELETE' | 'REPLACE' | 'FIND';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: complete list above ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Func_Decl : 'FUNCTION' name=IDENTIFIER ( ':' returnType=Data_Type_Access )? usings+=Using_Directive* ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
		////		'END_FUNCTION';
		////IO_Var_Decls : Input_Decls | Output_Decls | In_Out_Decls;
		////Func_Var_Decls : External_Var_Decls | Var_Decls;
		////
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: other languages on list below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Func_Body : / *Ladder_Diagram | FB_Diagram | Instruction_List |* / Stmt_List;// | Other_Languages;
		////
		////
		////// Table 40 – Function block type declaration
		////
		////// Table 41 - Function block instance declaration
		////FB_Type_Name : Std_FB_Name | IDENTIFIER;
		////FB_Type_Access : Qualified_Prefix FB_Type_Name | FB_Type_Name;
		////Std_FB_Name : 'SR' | 'RS' | 'R_TRIG' | 'F_TRIG' | 'CTU'| 'CTD' | 'CTUD' | 'TP' | 'TON' | 'TOF';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: complete list above ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////FB_Decl : 'FUNCTION_BLOCK' modifier=( 'FINAL' | 'ABSTRACT' )? name=IDENTIFIER usings+=Using_Directive* ( 'EXTENDS' extends=( FB_Type_Access | Qualified_Name ) )?
		////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( ios+=FB_IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls )*
		////	( methods+=Method_Decl )* body=FB_Body ? 
		////	'END_FUNCTION_BLOCK';
		////FB_IO_Var_Decls : FB_Input_Decls | FB_Output_Decls | In_Out_Decls;
		////FB_Input_Decls : {FB_Input_Decls} 'VAR_INPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Input_Decl ';' )* 'END_VAR';
		////FB_Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
		////FB_Output_Decls : {FB_Output_Decls} 'VAR_OUTPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Output_Decl ';' )* 'END_VAR';
		////FB_Output_Decl : Var_Decl_Init | Array_Conform_Decl;
		////Other_Var_Decls : Retain_Var_Decls | No_Retain_Var_Decls | Loc_Partly_Var_Decl;
		////No_Retain_Var_Decls : {No_Retain_Var_Decls} 'VAR' 'NON_RETAIN' access=Access_Spec ? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: other languages on list below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////FB_Body : Stmt_List; //| SFC | Ladder_Diagram | FB_Diagram | Instruction_List | Other_Languages;
		////Method_Decl : 'METHOD' access=Access_Spec type=( 'FINAL' | 'ABSTRACT' )? override?='OVERRIDE'?
		////	name=IDENTIFIER ( ':' returnType=Data_Type_Access )? ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
		////	'END_METHOD';
		////
		////// Table 48 - Class
		////
		////// Table 50 Textual call of methods – Formal and non-formal parameter list
		////Class_Decl : 'CLASS' modifier=( 'FINAL' | 'ABSTRACT' )? name=IDENTIFIER usings+=Using_Directive* ( 'EXTENDS' extends=Qualified_Name )? 
		////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( variables+=Func_Var_Decls | others+=Other_Var_Decls )* ( methods+=Method_Decl )* 
		////	'END_CLASS';
		////Class_Instance_Name : Qualified_Name '^' *;
		////Interface_Decl : 'INTERFACE' name=IDENTIFIER usings+=Using_Directive* 
		////	( 'EXTENDS' extends+=Interface_Name_List )? 
		////	methods+=Method_Prototype* 
		////	'END_INTERFACE';
		////Method_Prototype : 'METHOD' name=IDENTIFIER ( ':' returnType=Data_Type_Access )? ios+=IO_Var_Decls* 
		////	'END_METHOD';
		////Interface_Spec_Init : variables=Variable_List ( ASSIGNMENT initialization=Interface_Value )?;
		////Interface_Value : ((variable=Symbolic_Variable) | variableName=(FB_Instance_Name | Class_Instance_Name | 'NULL'));
		////Interface_Name_List : interfaces+=Qualified_Name ( ',' interfaces+=Qualified_Name )*;
		////Access_Spec : 'PUBLIC' | 'PROTECTED' | 'PRIVATE' | 'INTERNAL';
		////
		////// Table 47 - Program declaration
		////Prog_Decl : 'PROGRAM' name=IDENTIFIER
		////	( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls | locals+=Loc_Var_Decls | acesses+=Prog_Access_Decls )* 
		////body=FB_Body 'END_PROGRAM';
		////Prog_Access_Decls : {Prog_Access_Decls} 'VAR_ACCESS' ( accesses+=Prog_Access_Decl ';' )* 'END_VAR';
		////Prog_Access_Decl : name=IDENTIFIER ':' variable=Symbolic_Variable access=Multibit_Part_Access? ':' dataType=Data_Type_Access direction=Access_Direction?;
		////
		////// Table 62 - Configuration and resource declaration
		//////Config_Decl : 'CONFIGURATION' Config_Name Global_Var_Decls ?
		//////( Single_Resource_Decl | Resource_Decl + ) Access_Decls ? Config_Init ?
		//////'END_CONFIGURATION';
		//////Resource_Decl : 'RESOURCE' Resource_Name 'ON' Resource_Type_Name
		//////Global_Var_Decls ? Single_Resource_Decl
		//////'END_RESOURCE';
		//////Single_Resource_Decl : ( Task_Config ';' )* ( Prog_Config ';' )+;
		//////Access_Decls : 'VAR_ACCESS' ( Access_Decl ';' )* 'END_VAR';
		//////Access_Decl : IDENTIFIER ':' Access_Path ':' Data_Type_Access Access_Direction ?;
		//////Access_Path : ( Resource_Name Dot )? Direct_Variable
		//////| ( Resource_Name Dot )? ( Prog_Name Dot )?
		//////( ( FB_Instance_Name | Class_Instance_Name ) Dot )* Symbolic_Variable;
		//////Global_Var_Access : ( Resource_Name Dot )? IDENTIFIER ( Dot Struct_Elem_Name )?;
		//////Prog_Output_Access : Prog_Name Dot Symbolic_Variable;
		////Access_Direction : 'READ_WRITE' | 'READ_ONLY';
		//////Task_Config : 'TASK' Task_Name Task_Init;
		//////Task_Init : '(' ( 'SINGLE' ASSIGNMENT Data_Source ',' )?
		//////( 'INTERVAL' ASSIGNMENT Data_Source ',' )?
		//////'PRIORITY' ASSIGNMENT Unsigned_Int ')';
		//////Data_Source : Constant | Global_Var_Access | Prog_Output_Access | Direct_Variable;
		//////Prog_Config : 'PROGRAM' ( 'RETAIN' | 'NON_RETAIN' )? Prog_Name ( 'WITH' Task_Name )? ':'
		//////Prog_Type_Access ( '(' Prog_Conf_Elems ')' )?;
		//////Prog_Conf_Elems : Prog_Conf_Elem ( ',' Prog_Conf_Elem )*;
		//////Prog_Conf_Elem : FB_Task | Prog_Cnxn;
		//////FB_Task : FB_Instance_Name 'WITH' Task_Name;
		//////Prog_Cnxn : Symbolic_Variable ASSIGNMENT Prog_Data_Source | Symbolic_Variable '=>' Data_Sink;
		//////Prog_Data_Source : Constant | Enum_Value | Global_Var_Access | Direct_Variable;
		//////Data_Sink : Global_Var_Access | Direct_Variable;
		//////Config_Init : 'VAR_CONFIG' ( Config_Inst_Init ';' )* 'END_VAR';
		//////Config_Inst_Init : Resource_Name Dot Prog_Name Dot ( ( FB_Instance_Name | Class_Instance_Name ) Dot )*
		//////( IDENTIFIER Located_At ? ':' Loc_Var_Spec_Init
		//////| ( ( FB_Instance_Name ':' FB_Type_Access )
		//////| ( Class_Instance_Name ':' Qualified_Name ) ) ASSIGNMENT Struct_Init );
		//////
		//////// Table 64 - Namespace
		//////Namespace_Decl : 'NAMESPACE' 'INTERNAL' ? Namespace_H_Name Using_Directive * Namespace_Elements
		//////'END_NAMESPACE';
		//////Namespace_Elements : ( Data_Type_Decl | Func_Decl | FB_Decl
		//////| Class_Decl | Interface_Decl | Namespace_Decl )+;
		////Using_Directive : 'USING' namespaces+=Qualified_Name ( ',' namespaces+=Qualified_Name )* ';';
		//////POU_Decl : Using_Directive *
		//////( Global_Var_Decls | Data_Type_Decl | Access_Decls
		//////| Func_Decl | FB_Decl | Class_Decl | Interface_Decl
		//////| Namespace_Decl )+;
		//////
		////
		////// Table 71 - 72 - Language Structured Text (ST)
		////Expression returns Expression: Xor_Expr ({Expression.left=current} operator='OR' right=Xor_Expr )*;
		////// a constant expression must evaluate to a constant value at compile time
		////Constant_Expr : Expression;
		////Xor_Expr returns Expression: And_Expr ({Xor_Expr.left=current} operator='XOR' right=And_Expr )*;
		////And_Expr returns Expression: Compare_Expr ({And_Expr.left=current} operator=( '&' | 'AND' ) right=Compare_Expr )*;
		////Compare_Expr returns Expression: Equ_Expr ({Compare_Expr.left=current} operator=( '=' | '<>' ) right=Equ_Expr )*;
		////Equ_Expr returns Expression: Add_Expr ({Equ_Expr.left=current} operator=( '<' | '>' | '<=' | '>=' ) right=Add_Expr )*;
		////Add_Expr returns Expression: Term ({Add_Expr.left=current} operator=Number_Sign right=Term )*;
		////Term returns Expression: Power_Expr ({Term.left=current} operator=('*' | '/' | 'MOD') right=Power_Expr )*;
		////Power_Expr returns Expression: Unary_Expr ({Power_Expr.left=current} operator='**' right=Unary_Expr )*;
		////Unary_Expr returns Expression: operator=('-' | '+' | 'NOT')? expression=Primary_Expr;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call |  Ref_Value | '(' Expression ')'^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Primary_Expr returns Expression: {Expression} Constant | Enum_Value | Variable_Access / * | Func_Call |  Ref_Value | '(' Expression ')' * /;
		////
		////Variable_Access : variable=Variable access=Multibit_Part_Access ?;
		////Multibit_Part_Access : Dot ( accessSize=Unsigned_Int | accessSizeInfo=Size_Info );
		////Size_Info : '%' sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' ) ? size=Unsigned_Int;
		////Func_Call : access=Qualified_Name '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////Stmt_List : {Stmt_List} ( statement+=Stmt ? ';' )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Assign_Stmt | Subprog_Ctrl_Stmt |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Stmt : / * Assign_Stmt | Subprog_Ctrl_Stmt | * / Selection_Stmt | Iteration_Stmt;
		////Assign_Stmt : Variable_Assign_Stmt | Ref_Assign | Assignment_Attempt;
		////Variable_Assign_Stmt : left=Variable ASSIGNMENT right=Expression;
		////Assignment_Attempt : ( leftName=IDENTIFIER | leftReference=Ref_Deref ) '?=' ( rightName=IDENTIFIER | rightReference=(Ref_Deref | Ref_Value) );
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below | Qualified_Method_Call^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Invocation : method=( FB_Instance_Name | IDENTIFIER | 'THIS' / * | Qualified_Method_Call * / ) '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////// Qualified_Method_Call : ( ( 'THIS' Dot )? ( ( ( FB_Instance_Name | Class_Instance_Name ) Dot )+ ) IDENTIFIER );
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Subprog_Ctrl_Stmt : / * Func_Call | Invocation | * / Super_Invocation | Return;
		////Sub_Invocation: Super_Invocation | Return;
		////Super_Invocation : 'SUPER' '(' ')';
		////Return : 'RETURN';
		////Param_Assign : Named_Value | Ref_Assign | Linked_Value;
		////Named_Value : ( name=IDENTIFIER ASSIGNMENT )? value=Expression;
		////Linked_Value : (negated?='NOT')? name=IDENTIFIER '=>' value=Variable;
		////Selection_Stmt : IF_Stmt | Case_Stmt;
		////IF_Stmt : 'IF' condition=Expression 'THEN' statements=Stmt_List ( elseifs+=ELSEIF_Stmt )* ( else=ELSE_Stmt )? 'END_IF';
		////ELSEIF_Stmt : 'ELSIF' condition=Expression 'THEN' statements=Stmt_List;
		////ELSE_Stmt: 'ELSE' statements=Stmt_List;
		////Case_Stmt : 'CASE' expression=Expression 'OF' cases+=Case_Selection + ( 'ELSE' defaultStatements=Stmt_List )? 'END_CASE';
		////Case_Selection : values=Case_List ':' statements=Stmt_List;
		////Case_List : caseValues+=Case_List_Elem ( ',' caseValues+=Case_List_Elem )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Case_List_Elem : Subrange / *| Constant_Expr* /;
		////Iteration_Stmt : For_Stmt | While_Stmt | Repeat_Stmt | Exit_Stmt | Continue_Stmt;
		////Exit_Stmt : {Exit_Stmt} 'EXIT';
		////Continue_Stmt : {Continue_Stmt} 'CONTINUE';
		////For_Stmt : 'FOR' variable=IDENTIFIER ASSIGNMENT bounds=For_List 'DO' statements=Stmt_List 'END_FOR';
		////For_List : lowBound=Expression 'TO' upBound=Expression ( 'BY' step=Expression )?;
		////While_Stmt : 'WHILE' condition=Expression 'DO' statements=Stmt_List 'END_WHILE';
		////Repeat_Stmt : 'REPEAT' statements=Stmt_List 'UNTIL' condition=Expression 'END_REPEAT'; Date_And_Time_Value:
		//	("DATE_AND_TIME" | "LDATE_AND_TIME" | "DT" | "LDT") "#" DATE_LITERAL "-" DAYTIME_VALUE;
		public ParserRule getRule() { return rule; }

		//("DATE_AND_TIME" | "LDATE_AND_TIME" | "DT" | "LDT") "#" DATE_LITERAL "-" DAYTIME_VALUE //// Table 10 - Elementary data types
		////Data_Type_Access : Elem_Type_Name | Derived_Type_Access;
		////Elem_Type_Name : Numeric_Type_Name | 
		////	Bit_Str_Type_Name | 
		////	String_Type_Name | 
		////	Date_Type_Name | 
		////	Time_Type_Name
		////;
		////Numeric_Type_Name : Int_Type_Name | 
		////	Real_Type_Name
		////;
		////Int_Type_Name : Sign_Int_Type_Name | 
		////	Unsign_Int_Type_Name
		////;
		////Sign_Int_Type_Name : 'SINT' | 
		////	'INT' | 
		////	'DINT' | 
		////	'LINT';
		////Unsign_Int_Type_Name : 'USINT' | 
		////	'UINT' | 
		////	'UDINT' | 
		////	'ULINT';
		////Real_Type_Name : 'LREAL' | 
		////	'REAL';
		////SString_Type_Name : 'STRING' ( '[' Unsigned_Int ']' )?;
		////WString_Type_Name : 'WSTRING' ( '[' Unsigned_Int ']' )?;
		////String_Type_Name : SString_Type_Name | 
		////	WString_Type_Name | 
		////	'CHAR' | 
		////	'WCHAR';
		////Bit_Str_Type_Name : Bool_Type_Name | 
		////	Multibits_Type_Name
		////;
		////Bool_Type_Name : 'BOOL';
		////Multibits_Type_Name : 'BYTE' | 
		////	'WORD' | 
		////	'DWORD' | 
		////	'LWORD';
		////
		////
		////// Table 11 - Declaration of user-defined data types and initialization
		////Derived_Type_Access : Qualified_Name | 
		////	String_Type_Access
		////;
		////String_Type_Access : Qualified_Prefix String_Type_Name;
		////Qualified_Prefix : ( IDENTIFIER Dot )+ ;
		////Qualified_Name : (Qualified_Prefix IDENTIFIER) | IDENTIFIER;
		////This_Qualified_Name : 'THIS' Dot Qualified_Name;
		////Data_Type_Decl : 'TYPE' ( typeDeclarations+=Type_Decl ';' )+ 'END_TYPE';
		////Struct_Decl :'STRUCT' (overlap?='OVERLAP')? ( elements+=Struct_Elem_Decl ';' )+ 'END_STRUCT';
		////Type_Decl : Simple_Type_Decl | Subrange_Type_Decl | Enum_Type_Decl | Array_Type_Decl | Struct_Type_Decl | Str_Type_Decl | Ref_Type_Decl;
		////Simple_Type_Decl : type=IDENTIFIER ':' initialization=Simple_Spec_Init;
		////Subrange_Type_Decl : type=IDENTIFIER ':' initialization=Subrange_Spec_Init;
		////Enum_Type_Decl : type=IDENTIFIER ':' initialization=( Elem_Named_Spec | Enum_Spec_Init );
		////Array_Type_Decl : type=IDENTIFIER ':' initialization=Array_Spec_Init;
		////Struct_Type_Decl : type=IDENTIFIER ':' initialization=Struct_Spec;
		////Struct_Elem_Decl : type=IDENTIFIER ( location=Located_At access=Multibit_Part_Access ? )? ':' initialization=( Simple_Spec_Init | Subrange_Spec_Init | Enum_Spec_Init | Array_Spec_Init | Struct_Spec_Init );
		////Str_Type_Decl : type=String_Type_Name ':' initialization=String_Type_Name ( ASSIGNMENT initialValue=Char_Str )?;
		////
		////Simple_Spec : type=(Elem_Type_Name | Qualified_Name);
		////Subrange_Spec : (type=Int_Type_Name '(' range=Subrange ')') | (refRange=Qualified_Name);
		////Enum_Value_Spec : type=IDENTIFIER ( ASSIGNMENT ( initialValue=Int_Literal | initialization=Constant_Expr ) )?;
		////Elem_Named_Spec : type=Elem_Type_Name ? initialization=Named_Spec_Init;
		////Array_Spec : type=(Qualified_Name | 'ARRAY') '[' ranges+=Subrange ( ',' ranges+=Subrange )* ']' 'OF' refDataType=Data_Type_Access;
		////Struct_Spec : Struct_Decl | Struct_Spec_Init;
		////Simple_Spec_Init : type=Simple_Spec ( ASSIGNMENT initialValue=Constant_Expr )?;
		////Subrange_Spec_Init : type=Subrange_Spec ( ASSIGNMENT initialValue=Signed_Int )?;
		////Subrange : lowBound=Constant_Expr '..' upBound=Constant_Expr;
		////Named_Spec_Init : '(' initialValues+=Enum_Value_Spec ( ',' initialValues+=Enum_Value_Spec )* ')' ( ASSIGNMENT value=Enum_Value )?;
		////
		////Enum_Spec_Init : type=( Enum_Item | Enum_Items | Qualified_Name ) ( ASSIGNMENT value=Enum_Value)?;
		////Enum_Item : '(' IDENTIFIER ')';
		////Enum_Items : '(' IDENTIFIER ( ','  IDENTIFIER )+ ')' ;
		////Enum_Value : value=(Enum_Qualified_Id | IDENTIFIER);
		////Enum_Qualified_Id : Qualified_Name '#' IDENTIFIER;
		////Array_Spec_Init : type=Array_Spec ( ASSIGNMENT initialValue=Array_Init )?;
		////Array_Init : '[' initialValues+=Array_Elem_Init ( ',' initialValues+=Array_Elem_Init )* ']';
		////Array_Elem_Init : (initialization=Array_Elem_Init_Value | initialValue=Unsigned_Int) '(' bound=Array_Elem_Init_Value ? ')';
		////Array_Elem_Init_Value : Constant_Expr | Enum_Value | Struct_Init | Array_Init;
		////
		////Struct_Spec_Init : type=Qualified_Name ( ASSIGNMENT initialValue=Struct_Init )?;
		////Struct_Init : '(' elementInits+=Struct_Elem_Init ( ',' elementInits+=Struct_Elem_Init )* ')';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: uncomment Constant_Expr below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Struct_Elem_Init : type=IDENTIFIER ASSIGNMENT initialization=( / * Constant_Expr | * / Enum_Value | Array_Init | Ref_Value | Struct_Init );
		////
		////
		////// Table 16 - Directly represented variables
		////Direct_Variable : '%' locationPrefix=( 'I' | 'Q' | 'M' ) sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' )? bitIndexes+=Unsigned_Int ( Dot bitIndexes+=Unsigned_Int )*;
		////
		////
		////// Table 12 - Reference operations
		////Ref_Type_Decl : type=IDENTIFIER ':' initialization=Ref_Spec_Init;
		////Ref_Spec_Init : type=Ref_Spec ( ASSIGNMENT initialValue=Ref_Value )?;
		////Ref_Spec : 'REF_TO' + reference=Data_Type_Access;
		////Ref_Value : {Ref_Value} (reference=Ref_Addr | 'NULL');
		////Ref_Addr : 'REF' '(' ( referencedVar=Symbolic_Variable | referencedName=(FB_Instance_Name | Class_Instance_Name ) ) ')';
		////Ref_Assign : type=IDENTIFIER ASSIGNMENT ( initialValue=IDENTIFIER | initialization=(Ref_Deref | Ref_Value) );
		////Ref_Deref : name= IDENTIFIER '^'+;
		////
		////
		////// Table 13 - Declaration of variables/Table 14 – Initialization of variables
		////Variable : Direct_Variable | Symbolic_Variable;
		////Symbolic_Variable : name=This_Qualified_Name variable=( Var_Access | Multi_Elem_Var );
		////Var_Access : {Var_Access} (variable=IDENTIFIER | reference=Ref_Deref);
		////Multi_Elem_Var : access=Var_Access elements+=( Subscript_List | Struct_Variable )+;
		////Subscript_List : '[' item+=Subscript ( ',' item+=Subscript )* ']';
		////Subscript : Expression;
		////Struct_Variable : Dot Struct_Elem_Select;
		////Struct_Elem_Select : Var_Access;
		////Input_Decls : {Input_Decls} 'VAR_INPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( inputs+=Input_Decl ';' )* 'END_VAR';
		////Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
		////Edge_Decl : variables=Variable_List ':' Bool_Type_Name edgeType=( 'R_EDGE' | 'F_EDGE' );
		////Var_Decl_Init : variables=Variable_List ':' initialization=(( Simple_Spec_Init | Str_Var_Decl | Ref_Spec_Init ) | Array_Var_Decl_Init | Struct_Var_Decl_Init | FB_Decl_Init | Interface_Spec_Init);
		////Ref_Var_Decl : variables=Variable_List ':' initialization=Ref_Spec;
		////Interface_Var_Decl : variables=Variable_List ':' initialization=Qualified_Name;
		////Variable_List : variables+=IDENTIFIER ( ',' variables+=IDENTIFIER )*;
		////Array_Var_Decl_Init : variables=Variable_List ':' initialization=Array_Spec_Init;
		////Array_Conformand : 'ARRAY' '[' '*' ( ',' '*' )* ']' 'OF' dataType=Data_Type_Access;
		////Array_Conform_Decl : variables=Variable_List ':' conformand=Array_Conformand;
		////Struct_Var_Decl_Init : variables=Variable_List ':' initialization=Struct_Spec_Init;
		////FB_Decl_No_Init : (names+=IDENTIFIER ( ',' names+=IDENTIFIER )*) ':' type=FB_Type_Access;
		////FB_Decl_Init : fb=FB_Decl_No_Init ( ASSIGNMENT initialization=Struct_Init )?;
		////FB_Instance_Name : Qualified_Name '^'*;
		////Output_Decls : {Output_Decls} 'VAR_OUTPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( outputs+=Output_Decl ';' )* 
		////	'END_VAR';
		////Output_Decl : Var_Decl_Init | Array_Conform_Decl;
		////In_Out_Decls : {In_Out_Decls} 'VAR_IN_OUT' ( inouts+=In_Out_Var_Decl ';' )* 
		////	'END_VAR';
		////In_Out_Var_Decl : Var_Decl | Array_Conform_Decl | FB_Decl_No_Init;
		////Var_Decl : variables=Variable_List ':' initialization=( Simple_Spec | Str_Var_Decl | Array_Var_Decl | Struct_Var_Decl );
		////Array_Var_Decl : variables=Variable_List ':' initialization=Array_Spec;
		////Struct_Var_Decl : variables=Variable_List ':' initialization=Qualified_Name;
		////Var_Decls : {Var_Decls} 'VAR' (constant?='CONSTANT' ?) access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////Retain_Var_Decls : {Retain_Var_Decls} 'VAR' 'RETAIN' access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////Loc_Var_Decls : {Loc_Var_Decls} 'VAR' modifier=( 'CONSTANT' | 'RETAIN' | 'NON_RETAIN' )? ( variables+=Loc_Var_Decl ';' )* 'END_VAR';
		////Loc_Var_Decl : name=IDENTIFIER ? location=Located_At ':' initialization=Loc_Var_Spec_Init;
		////Temp_Var_Decls : {Temp_Var_Decls} 'VAR_TEMP' ( variables+=( Var_Decl | Ref_Var_Decl | Interface_Var_Decl ) ';' )* 'END_VAR';
		////External_Var_Decls : {External_Var_Decls} 'VAR_EXTERNAL' (constant?='Constant' ?) ( variables+=External_Decl ';' )* 'END_VAR';
		////External_Decl : name=IDENTIFIER ':' ( initialization=(Simple_Spec | Array_Spec) | type=(Qualified_Name | FB_Type_Access | Qualified_Name ));
		////Global_Var_Decls : {Global_Var_Decls} 'VAR_GLOBAL' modifier=( 'CONSTANT' | 'RETAIN' )? ( variables+=Global_Var_Decl ';' )* 'END_VAR';
		////Global_Var_Decl : name=Global_Var_Spec ':' ( initialization=Loc_Var_Spec_Init | type=FB_Type_Access );
		////Global_Var_Spec : ( variables+=IDENTIFIER ( ',' variables+=IDENTIFIER )* ) | ( variables+=IDENTIFIER location=Located_At );
		////Loc_Var_Spec_Init : Simple_Spec_Init | Array_Spec_Init | Struct_Spec_Init | S_Byte_Str_Spec | D_Byte_Str_Spec;
		////Located_At : 'AT' Direct_Variable;
		////Str_Var_Decl : S_Byte_Str_Var_Decl | D_Byte_Str_Var_Decl;
		////S_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=S_Byte_Str_Spec;
		////S_Byte_Str_Spec : {S_Byte_Str_Spec} 'STRING' ( '[' bound=Unsigned_Int ']' )? ( ASSIGNMENT initialValue=S_Byte_Char_Str )?;
		////D_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=D_Byte_Str_Spec;
		////D_Byte_Str_Spec : {D_Byte_Str_Spec} 'WSTRING' ( '[' bound=Unsigned_Int ']' )? ( ASSIGNMENT initialValue=D_Byte_Char_Str )?;
		////Loc_Partly_Var_Decl : {Loc_Partly_Var_Decl} 'VAR' modifier=( 'RETAIN' | 'NON_RETAIN' )? variables+=Loc_Partly_Var * 'END_VAR';
		////Loc_Partly_Var : name=IDENTIFIER 'AT' '%' locationPrefix=( 'I' | 'Q' | 'M' ) '*' ':' initialization=Var_Spec ';';
		////Var_Spec : Simple_Spec | Array_Spec | Qualified_Name | StringVar_Spec;
		////StringVar_Spec: type=( 'STRING' | 'WSTRING' ) ( '[' bound=Unsigned_Int ']' )?;
		////
		////// Table 19 - Function declaration
		////Func_Name : Std_Func_Name | IDENTIFIER;
		////Std_Func_Name : 'TRUNC' | 'ABS' | 'SQRT' | 'LN' | 'LOG' | 'EXP' | 
		////	'SIN' | 'COS' | 'TAN' | 'ASIN' | 'ACOS' | 'ATAN' | 'ATAN2 ' | 
		////	'ADD' | 'SUB' | 'MUL' | 'DIV' | 'MOD' | 'EXPT' | 'MOVE ' | 
		////	'SHL' | 'SHR' | 'ROL' | 'ROR' | 'AND' | 'OR'  | 'XOR' | 'NOT' | 
		////	'SEL' | 'MAX' | 'MIN' | 'LIMIT' | 'MUX ' | 'GT' | 'GE' | 'EQ' | 
		////	'LE' | 'LT' | 'NE' | 'LEN' | 'LEFT' | 'RIGHT' | 'MID' | 'CONCAT' | 
		////	'INSERT' | 'DELETE' | 'REPLACE' | 'FIND';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: complete list above ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Func_Decl : 'FUNCTION' name=IDENTIFIER ( ':' returnType=Data_Type_Access )? usings+=Using_Directive* ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
		////		'END_FUNCTION';
		////IO_Var_Decls : Input_Decls | Output_Decls | In_Out_Decls;
		////Func_Var_Decls : External_Var_Decls | Var_Decls;
		////
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: other languages on list below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Func_Body : / *Ladder_Diagram | FB_Diagram | Instruction_List |* / Stmt_List;// | Other_Languages;
		////
		////
		////// Table 40 – Function block type declaration
		////
		////// Table 41 - Function block instance declaration
		////FB_Type_Name : Std_FB_Name | IDENTIFIER;
		////FB_Type_Access : Qualified_Prefix FB_Type_Name | FB_Type_Name;
		////Std_FB_Name : 'SR' | 'RS' | 'R_TRIG' | 'F_TRIG' | 'CTU'| 'CTD' | 'CTUD' | 'TP' | 'TON' | 'TOF';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: complete list above ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////FB_Decl : 'FUNCTION_BLOCK' modifier=( 'FINAL' | 'ABSTRACT' )? name=IDENTIFIER usings+=Using_Directive* ( 'EXTENDS' extends=( FB_Type_Access | Qualified_Name ) )?
		////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( ios+=FB_IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls )*
		////	( methods+=Method_Decl )* body=FB_Body ? 
		////	'END_FUNCTION_BLOCK';
		////FB_IO_Var_Decls : FB_Input_Decls | FB_Output_Decls | In_Out_Decls;
		////FB_Input_Decls : {FB_Input_Decls} 'VAR_INPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Input_Decl ';' )* 'END_VAR';
		////FB_Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
		////FB_Output_Decls : {FB_Output_Decls} 'VAR_OUTPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Output_Decl ';' )* 'END_VAR';
		////FB_Output_Decl : Var_Decl_Init | Array_Conform_Decl;
		////Other_Var_Decls : Retain_Var_Decls | No_Retain_Var_Decls | Loc_Partly_Var_Decl;
		////No_Retain_Var_Decls : {No_Retain_Var_Decls} 'VAR' 'NON_RETAIN' access=Access_Spec ? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: other languages on list below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////FB_Body : Stmt_List; //| SFC | Ladder_Diagram | FB_Diagram | Instruction_List | Other_Languages;
		////Method_Decl : 'METHOD' access=Access_Spec type=( 'FINAL' | 'ABSTRACT' )? override?='OVERRIDE'?
		////	name=IDENTIFIER ( ':' returnType=Data_Type_Access )? ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
		////	'END_METHOD';
		////
		////// Table 48 - Class
		////
		////// Table 50 Textual call of methods – Formal and non-formal parameter list
		////Class_Decl : 'CLASS' modifier=( 'FINAL' | 'ABSTRACT' )? name=IDENTIFIER usings+=Using_Directive* ( 'EXTENDS' extends=Qualified_Name )? 
		////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( variables+=Func_Var_Decls | others+=Other_Var_Decls )* ( methods+=Method_Decl )* 
		////	'END_CLASS';
		////Class_Instance_Name : Qualified_Name '^' *;
		////Interface_Decl : 'INTERFACE' name=IDENTIFIER usings+=Using_Directive* 
		////	( 'EXTENDS' extends+=Interface_Name_List )? 
		////	methods+=Method_Prototype* 
		////	'END_INTERFACE';
		////Method_Prototype : 'METHOD' name=IDENTIFIER ( ':' returnType=Data_Type_Access )? ios+=IO_Var_Decls* 
		////	'END_METHOD';
		////Interface_Spec_Init : variables=Variable_List ( ASSIGNMENT initialization=Interface_Value )?;
		////Interface_Value : ((variable=Symbolic_Variable) | variableName=(FB_Instance_Name | Class_Instance_Name | 'NULL'));
		////Interface_Name_List : interfaces+=Qualified_Name ( ',' interfaces+=Qualified_Name )*;
		////Access_Spec : 'PUBLIC' | 'PROTECTED' | 'PRIVATE' | 'INTERNAL';
		////
		////// Table 47 - Program declaration
		////Prog_Decl : 'PROGRAM' name=IDENTIFIER
		////	( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls | locals+=Loc_Var_Decls | acesses+=Prog_Access_Decls )* 
		////body=FB_Body 'END_PROGRAM';
		////Prog_Access_Decls : {Prog_Access_Decls} 'VAR_ACCESS' ( accesses+=Prog_Access_Decl ';' )* 'END_VAR';
		////Prog_Access_Decl : name=IDENTIFIER ':' variable=Symbolic_Variable access=Multibit_Part_Access? ':' dataType=Data_Type_Access direction=Access_Direction?;
		////
		////// Table 62 - Configuration and resource declaration
		//////Config_Decl : 'CONFIGURATION' Config_Name Global_Var_Decls ?
		//////( Single_Resource_Decl | Resource_Decl + ) Access_Decls ? Config_Init ?
		//////'END_CONFIGURATION';
		//////Resource_Decl : 'RESOURCE' Resource_Name 'ON' Resource_Type_Name
		//////Global_Var_Decls ? Single_Resource_Decl
		//////'END_RESOURCE';
		//////Single_Resource_Decl : ( Task_Config ';' )* ( Prog_Config ';' )+;
		//////Access_Decls : 'VAR_ACCESS' ( Access_Decl ';' )* 'END_VAR';
		//////Access_Decl : IDENTIFIER ':' Access_Path ':' Data_Type_Access Access_Direction ?;
		//////Access_Path : ( Resource_Name Dot )? Direct_Variable
		//////| ( Resource_Name Dot )? ( Prog_Name Dot )?
		//////( ( FB_Instance_Name | Class_Instance_Name ) Dot )* Symbolic_Variable;
		//////Global_Var_Access : ( Resource_Name Dot )? IDENTIFIER ( Dot Struct_Elem_Name )?;
		//////Prog_Output_Access : Prog_Name Dot Symbolic_Variable;
		////Access_Direction : 'READ_WRITE' | 'READ_ONLY';
		//////Task_Config : 'TASK' Task_Name Task_Init;
		//////Task_Init : '(' ( 'SINGLE' ASSIGNMENT Data_Source ',' )?
		//////( 'INTERVAL' ASSIGNMENT Data_Source ',' )?
		//////'PRIORITY' ASSIGNMENT Unsigned_Int ')';
		//////Data_Source : Constant | Global_Var_Access | Prog_Output_Access | Direct_Variable;
		//////Prog_Config : 'PROGRAM' ( 'RETAIN' | 'NON_RETAIN' )? Prog_Name ( 'WITH' Task_Name )? ':'
		//////Prog_Type_Access ( '(' Prog_Conf_Elems ')' )?;
		//////Prog_Conf_Elems : Prog_Conf_Elem ( ',' Prog_Conf_Elem )*;
		//////Prog_Conf_Elem : FB_Task | Prog_Cnxn;
		//////FB_Task : FB_Instance_Name 'WITH' Task_Name;
		//////Prog_Cnxn : Symbolic_Variable ASSIGNMENT Prog_Data_Source | Symbolic_Variable '=>' Data_Sink;
		//////Prog_Data_Source : Constant | Enum_Value | Global_Var_Access | Direct_Variable;
		//////Data_Sink : Global_Var_Access | Direct_Variable;
		//////Config_Init : 'VAR_CONFIG' ( Config_Inst_Init ';' )* 'END_VAR';
		//////Config_Inst_Init : Resource_Name Dot Prog_Name Dot ( ( FB_Instance_Name | Class_Instance_Name ) Dot )*
		//////( IDENTIFIER Located_At ? ':' Loc_Var_Spec_Init
		//////| ( ( FB_Instance_Name ':' FB_Type_Access )
		//////| ( Class_Instance_Name ':' Qualified_Name ) ) ASSIGNMENT Struct_Init );
		//////
		//////// Table 64 - Namespace
		//////Namespace_Decl : 'NAMESPACE' 'INTERNAL' ? Namespace_H_Name Using_Directive * Namespace_Elements
		//////'END_NAMESPACE';
		//////Namespace_Elements : ( Data_Type_Decl | Func_Decl | FB_Decl
		//////| Class_Decl | Interface_Decl | Namespace_Decl )+;
		////Using_Directive : 'USING' namespaces+=Qualified_Name ( ',' namespaces+=Qualified_Name )* ';';
		//////POU_Decl : Using_Directive *
		//////( Global_Var_Decls | Data_Type_Decl | Access_Decls
		//////| Func_Decl | FB_Decl | Class_Decl | Interface_Decl
		//////| Namespace_Decl )+;
		//////
		////
		////// Table 71 - 72 - Language Structured Text (ST)
		////Expression returns Expression: Xor_Expr ({Expression.left=current} operator='OR' right=Xor_Expr )*;
		////// a constant expression must evaluate to a constant value at compile time
		////Constant_Expr : Expression;
		////Xor_Expr returns Expression: And_Expr ({Xor_Expr.left=current} operator='XOR' right=And_Expr )*;
		////And_Expr returns Expression: Compare_Expr ({And_Expr.left=current} operator=( '&' | 'AND' ) right=Compare_Expr )*;
		////Compare_Expr returns Expression: Equ_Expr ({Compare_Expr.left=current} operator=( '=' | '<>' ) right=Equ_Expr )*;
		////Equ_Expr returns Expression: Add_Expr ({Equ_Expr.left=current} operator=( '<' | '>' | '<=' | '>=' ) right=Add_Expr )*;
		////Add_Expr returns Expression: Term ({Add_Expr.left=current} operator=Number_Sign right=Term )*;
		////Term returns Expression: Power_Expr ({Term.left=current} operator=('*' | '/' | 'MOD') right=Power_Expr )*;
		////Power_Expr returns Expression: Unary_Expr ({Power_Expr.left=current} operator='**' right=Unary_Expr )*;
		////Unary_Expr returns Expression: operator=('-' | '+' | 'NOT')? expression=Primary_Expr;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call |  Ref_Value | '(' Expression ')'^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Primary_Expr returns Expression: {Expression} Constant | Enum_Value | Variable_Access / * | Func_Call |  Ref_Value | '(' Expression ')' * /;
		////
		////Variable_Access : variable=Variable access=Multibit_Part_Access ?;
		////Multibit_Part_Access : Dot ( accessSize=Unsigned_Int | accessSizeInfo=Size_Info );
		////Size_Info : '%' sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' ) ? size=Unsigned_Int;
		////Func_Call : access=Qualified_Name '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////Stmt_List : {Stmt_List} ( statement+=Stmt ? ';' )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Assign_Stmt | Subprog_Ctrl_Stmt |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Stmt : / * Assign_Stmt | Subprog_Ctrl_Stmt | * / Selection_Stmt | Iteration_Stmt;
		////Assign_Stmt : Variable_Assign_Stmt | Ref_Assign | Assignment_Attempt;
		////Variable_Assign_Stmt : left=Variable ASSIGNMENT right=Expression;
		////Assignment_Attempt : ( leftName=IDENTIFIER | leftReference=Ref_Deref ) '?=' ( rightName=IDENTIFIER | rightReference=(Ref_Deref | Ref_Value) );
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below | Qualified_Method_Call^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Invocation : method=( FB_Instance_Name | IDENTIFIER | 'THIS' / * | Qualified_Method_Call * / ) '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////// Qualified_Method_Call : ( ( 'THIS' Dot )? ( ( ( FB_Instance_Name | Class_Instance_Name ) Dot )+ ) IDENTIFIER );
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Subprog_Ctrl_Stmt : / * Func_Call | Invocation | * / Super_Invocation | Return;
		////Sub_Invocation: Super_Invocation | Return;
		////Super_Invocation : 'SUPER' '(' ')';
		////Return : 'RETURN';
		////Param_Assign : Named_Value | Ref_Assign | Linked_Value;
		////Named_Value : ( name=IDENTIFIER ASSIGNMENT )? value=Expression;
		////Linked_Value : (negated?='NOT')? name=IDENTIFIER '=>' value=Variable;
		////Selection_Stmt : IF_Stmt | Case_Stmt;
		////IF_Stmt : 'IF' condition=Expression 'THEN' statements=Stmt_List ( elseifs+=ELSEIF_Stmt )* ( else=ELSE_Stmt )? 'END_IF';
		////ELSEIF_Stmt : 'ELSIF' condition=Expression 'THEN' statements=Stmt_List;
		////ELSE_Stmt: 'ELSE' statements=Stmt_List;
		////Case_Stmt : 'CASE' expression=Expression 'OF' cases+=Case_Selection + ( 'ELSE' defaultStatements=Stmt_List )? 'END_CASE';
		////Case_Selection : values=Case_List ':' statements=Stmt_List;
		////Case_List : caseValues+=Case_List_Elem ( ',' caseValues+=Case_List_Elem )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Case_List_Elem : Subrange / *| Constant_Expr* /;
		////Iteration_Stmt : For_Stmt | While_Stmt | Repeat_Stmt | Exit_Stmt | Continue_Stmt;
		////Exit_Stmt : {Exit_Stmt} 'EXIT';
		////Continue_Stmt : {Continue_Stmt} 'CONTINUE';
		////For_Stmt : 'FOR' variable=IDENTIFIER ASSIGNMENT bounds=For_List 'DO' statements=Stmt_List 'END_FOR';
		////For_List : lowBound=Expression 'TO' upBound=Expression ( 'BY' step=Expression )?;
		////While_Stmt : 'WHILE' condition=Expression 'DO' statements=Stmt_List 'END_WHILE';
		////Repeat_Stmt : 'REPEAT' statements=Stmt_List 'UNTIL' condition=Expression 'END_REPEAT';
		public Group getGroup() { return cGroup; }

		//"DATE_AND_TIME" | "LDATE_AND_TIME" | "DT" | "LDT"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"DATE_AND_TIME"
		public Keyword getDATE_AND_TIMEKeyword_0_0() { return cDATE_AND_TIMEKeyword_0_0; }

		//"LDATE_AND_TIME"
		public Keyword getLDATE_AND_TIMEKeyword_0_1() { return cLDATE_AND_TIMEKeyword_0_1; }

		//"DT"
		public Keyword getDTKeyword_0_2() { return cDTKeyword_0_2; }

		//"LDT"
		public Keyword getLDTKeyword_0_3() { return cLDTKeyword_0_3; }

		//"#"
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }

		//DATE_LITERAL
		public RuleCall getDATE_LITERALTerminalRuleCall_2() { return cDATE_LITERALTerminalRuleCall_2; }

		//"-"
		public Keyword getHyphenMinusKeyword_3() { return cHyphenMinusKeyword_3; }

		////// Table 10 - Elementary data types
		////Data_Type_Access : Elem_Type_Name | Derived_Type_Access;
		////Elem_Type_Name : Numeric_Type_Name | 
		////	Bit_Str_Type_Name | 
		////	String_Type_Name | 
		////	Date_Type_Name | 
		////	Time_Type_Name
		////;
		////Numeric_Type_Name : Int_Type_Name | 
		////	Real_Type_Name
		////;
		////Int_Type_Name : Sign_Int_Type_Name | 
		////	Unsign_Int_Type_Name
		////;
		////Sign_Int_Type_Name : 'SINT' | 
		////	'INT' | 
		////	'DINT' | 
		////	'LINT';
		////Unsign_Int_Type_Name : 'USINT' | 
		////	'UINT' | 
		////	'UDINT' | 
		////	'ULINT';
		////Real_Type_Name : 'LREAL' | 
		////	'REAL';
		////SString_Type_Name : 'STRING' ( '[' Unsigned_Int ']' )?;
		////WString_Type_Name : 'WSTRING' ( '[' Unsigned_Int ']' )?;
		////String_Type_Name : SString_Type_Name | 
		////	WString_Type_Name | 
		////	'CHAR' | 
		////	'WCHAR';
		////Bit_Str_Type_Name : Bool_Type_Name | 
		////	Multibits_Type_Name
		////;
		////Bool_Type_Name : 'BOOL';
		////Multibits_Type_Name : 'BYTE' | 
		////	'WORD' | 
		////	'DWORD' | 
		////	'LWORD';
		////
		////
		////// Table 11 - Declaration of user-defined data types and initialization
		////Derived_Type_Access : Qualified_Name | 
		////	String_Type_Access
		////;
		////String_Type_Access : Qualified_Prefix String_Type_Name;
		////Qualified_Prefix : ( IDENTIFIER Dot )+ ;
		////Qualified_Name : (Qualified_Prefix IDENTIFIER) | IDENTIFIER;
		////This_Qualified_Name : 'THIS' Dot Qualified_Name;
		////Data_Type_Decl : 'TYPE' ( typeDeclarations+=Type_Decl ';' )+ 'END_TYPE';
		////Struct_Decl :'STRUCT' (overlap?='OVERLAP')? ( elements+=Struct_Elem_Decl ';' )+ 'END_STRUCT';
		////Type_Decl : Simple_Type_Decl | Subrange_Type_Decl | Enum_Type_Decl | Array_Type_Decl | Struct_Type_Decl | Str_Type_Decl | Ref_Type_Decl;
		////Simple_Type_Decl : type=IDENTIFIER ':' initialization=Simple_Spec_Init;
		////Subrange_Type_Decl : type=IDENTIFIER ':' initialization=Subrange_Spec_Init;
		////Enum_Type_Decl : type=IDENTIFIER ':' initialization=( Elem_Named_Spec | Enum_Spec_Init );
		////Array_Type_Decl : type=IDENTIFIER ':' initialization=Array_Spec_Init;
		////Struct_Type_Decl : type=IDENTIFIER ':' initialization=Struct_Spec;
		////Struct_Elem_Decl : type=IDENTIFIER ( location=Located_At access=Multibit_Part_Access ? )? ':' initialization=( Simple_Spec_Init | Subrange_Spec_Init | Enum_Spec_Init | Array_Spec_Init | Struct_Spec_Init );
		////Str_Type_Decl : type=String_Type_Name ':' initialization=String_Type_Name ( ASSIGNMENT initialValue=Char_Str )?;
		////
		////Simple_Spec : type=(Elem_Type_Name | Qualified_Name);
		////Subrange_Spec : (type=Int_Type_Name '(' range=Subrange ')') | (refRange=Qualified_Name);
		////Enum_Value_Spec : type=IDENTIFIER ( ASSIGNMENT ( initialValue=Int_Literal | initialization=Constant_Expr ) )?;
		////Elem_Named_Spec : type=Elem_Type_Name ? initialization=Named_Spec_Init;
		////Array_Spec : type=(Qualified_Name | 'ARRAY') '[' ranges+=Subrange ( ',' ranges+=Subrange )* ']' 'OF' refDataType=Data_Type_Access;
		////Struct_Spec : Struct_Decl | Struct_Spec_Init;
		////Simple_Spec_Init : type=Simple_Spec ( ASSIGNMENT initialValue=Constant_Expr )?;
		////Subrange_Spec_Init : type=Subrange_Spec ( ASSIGNMENT initialValue=Signed_Int )?;
		////Subrange : lowBound=Constant_Expr '..' upBound=Constant_Expr;
		////Named_Spec_Init : '(' initialValues+=Enum_Value_Spec ( ',' initialValues+=Enum_Value_Spec )* ')' ( ASSIGNMENT value=Enum_Value )?;
		////
		////Enum_Spec_Init : type=( Enum_Item | Enum_Items | Qualified_Name ) ( ASSIGNMENT value=Enum_Value)?;
		////Enum_Item : '(' IDENTIFIER ')';
		////Enum_Items : '(' IDENTIFIER ( ','  IDENTIFIER )+ ')' ;
		////Enum_Value : value=(Enum_Qualified_Id | IDENTIFIER);
		////Enum_Qualified_Id : Qualified_Name '#' IDENTIFIER;
		////Array_Spec_Init : type=Array_Spec ( ASSIGNMENT initialValue=Array_Init )?;
		////Array_Init : '[' initialValues+=Array_Elem_Init ( ',' initialValues+=Array_Elem_Init )* ']';
		////Array_Elem_Init : (initialization=Array_Elem_Init_Value | initialValue=Unsigned_Int) '(' bound=Array_Elem_Init_Value ? ')';
		////Array_Elem_Init_Value : Constant_Expr | Enum_Value | Struct_Init | Array_Init;
		////
		////Struct_Spec_Init : type=Qualified_Name ( ASSIGNMENT initialValue=Struct_Init )?;
		////Struct_Init : '(' elementInits+=Struct_Elem_Init ( ',' elementInits+=Struct_Elem_Init )* ')';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: uncomment Constant_Expr below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Struct_Elem_Init : type=IDENTIFIER ASSIGNMENT initialization=( / * Constant_Expr | * / Enum_Value | Array_Init | Ref_Value | Struct_Init );
		////
		////
		////// Table 16 - Directly represented variables
		////Direct_Variable : '%' locationPrefix=( 'I' | 'Q' | 'M' ) sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' )? bitIndexes+=Unsigned_Int ( Dot bitIndexes+=Unsigned_Int )*;
		////
		////
		////// Table 12 - Reference operations
		////Ref_Type_Decl : type=IDENTIFIER ':' initialization=Ref_Spec_Init;
		////Ref_Spec_Init : type=Ref_Spec ( ASSIGNMENT initialValue=Ref_Value )?;
		////Ref_Spec : 'REF_TO' + reference=Data_Type_Access;
		////Ref_Value : {Ref_Value} (reference=Ref_Addr | 'NULL');
		////Ref_Addr : 'REF' '(' ( referencedVar=Symbolic_Variable | referencedName=(FB_Instance_Name | Class_Instance_Name ) ) ')';
		////Ref_Assign : type=IDENTIFIER ASSIGNMENT ( initialValue=IDENTIFIER | initialization=(Ref_Deref | Ref_Value) );
		////Ref_Deref : name= IDENTIFIER '^'+;
		////
		////
		////// Table 13 - Declaration of variables/Table 14 – Initialization of variables
		////Variable : Direct_Variable | Symbolic_Variable;
		////Symbolic_Variable : name=This_Qualified_Name variable=( Var_Access | Multi_Elem_Var );
		////Var_Access : {Var_Access} (variable=IDENTIFIER | reference=Ref_Deref);
		////Multi_Elem_Var : access=Var_Access elements+=( Subscript_List | Struct_Variable )+;
		////Subscript_List : '[' item+=Subscript ( ',' item+=Subscript )* ']';
		////Subscript : Expression;
		////Struct_Variable : Dot Struct_Elem_Select;
		////Struct_Elem_Select : Var_Access;
		////Input_Decls : {Input_Decls} 'VAR_INPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( inputs+=Input_Decl ';' )* 'END_VAR';
		////Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
		////Edge_Decl : variables=Variable_List ':' Bool_Type_Name edgeType=( 'R_EDGE' | 'F_EDGE' );
		////Var_Decl_Init : variables=Variable_List ':' initialization=(( Simple_Spec_Init | Str_Var_Decl | Ref_Spec_Init ) | Array_Var_Decl_Init | Struct_Var_Decl_Init | FB_Decl_Init | Interface_Spec_Init);
		////Ref_Var_Decl : variables=Variable_List ':' initialization=Ref_Spec;
		////Interface_Var_Decl : variables=Variable_List ':' initialization=Qualified_Name;
		////Variable_List : variables+=IDENTIFIER ( ',' variables+=IDENTIFIER )*;
		////Array_Var_Decl_Init : variables=Variable_List ':' initialization=Array_Spec_Init;
		////Array_Conformand : 'ARRAY' '[' '*' ( ',' '*' )* ']' 'OF' dataType=Data_Type_Access;
		////Array_Conform_Decl : variables=Variable_List ':' conformand=Array_Conformand;
		////Struct_Var_Decl_Init : variables=Variable_List ':' initialization=Struct_Spec_Init;
		////FB_Decl_No_Init : (names+=IDENTIFIER ( ',' names+=IDENTIFIER )*) ':' type=FB_Type_Access;
		////FB_Decl_Init : fb=FB_Decl_No_Init ( ASSIGNMENT initialization=Struct_Init )?;
		////FB_Instance_Name : Qualified_Name '^'*;
		////Output_Decls : {Output_Decls} 'VAR_OUTPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( outputs+=Output_Decl ';' )* 
		////	'END_VAR';
		////Output_Decl : Var_Decl_Init | Array_Conform_Decl;
		////In_Out_Decls : {In_Out_Decls} 'VAR_IN_OUT' ( inouts+=In_Out_Var_Decl ';' )* 
		////	'END_VAR';
		////In_Out_Var_Decl : Var_Decl | Array_Conform_Decl | FB_Decl_No_Init;
		////Var_Decl : variables=Variable_List ':' initialization=( Simple_Spec | Str_Var_Decl | Array_Var_Decl | Struct_Var_Decl );
		////Array_Var_Decl : variables=Variable_List ':' initialization=Array_Spec;
		////Struct_Var_Decl : variables=Variable_List ':' initialization=Qualified_Name;
		////Var_Decls : {Var_Decls} 'VAR' (constant?='CONSTANT' ?) access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////Retain_Var_Decls : {Retain_Var_Decls} 'VAR' 'RETAIN' access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////Loc_Var_Decls : {Loc_Var_Decls} 'VAR' modifier=( 'CONSTANT' | 'RETAIN' | 'NON_RETAIN' )? ( variables+=Loc_Var_Decl ';' )* 'END_VAR';
		////Loc_Var_Decl : name=IDENTIFIER ? location=Located_At ':' initialization=Loc_Var_Spec_Init;
		////Temp_Var_Decls : {Temp_Var_Decls} 'VAR_TEMP' ( variables+=( Var_Decl | Ref_Var_Decl | Interface_Var_Decl ) ';' )* 'END_VAR';
		////External_Var_Decls : {External_Var_Decls} 'VAR_EXTERNAL' (constant?='Constant' ?) ( variables+=External_Decl ';' )* 'END_VAR';
		////External_Decl : name=IDENTIFIER ':' ( initialization=(Simple_Spec | Array_Spec) | type=(Qualified_Name | FB_Type_Access | Qualified_Name ));
		////Global_Var_Decls : {Global_Var_Decls} 'VAR_GLOBAL' modifier=( 'CONSTANT' | 'RETAIN' )? ( variables+=Global_Var_Decl ';' )* 'END_VAR';
		////Global_Var_Decl : name=Global_Var_Spec ':' ( initialization=Loc_Var_Spec_Init | type=FB_Type_Access );
		////Global_Var_Spec : ( variables+=IDENTIFIER ( ',' variables+=IDENTIFIER )* ) | ( variables+=IDENTIFIER location=Located_At );
		////Loc_Var_Spec_Init : Simple_Spec_Init | Array_Spec_Init | Struct_Spec_Init | S_Byte_Str_Spec | D_Byte_Str_Spec;
		////Located_At : 'AT' Direct_Variable;
		////Str_Var_Decl : S_Byte_Str_Var_Decl | D_Byte_Str_Var_Decl;
		////S_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=S_Byte_Str_Spec;
		////S_Byte_Str_Spec : {S_Byte_Str_Spec} 'STRING' ( '[' bound=Unsigned_Int ']' )? ( ASSIGNMENT initialValue=S_Byte_Char_Str )?;
		////D_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=D_Byte_Str_Spec;
		////D_Byte_Str_Spec : {D_Byte_Str_Spec} 'WSTRING' ( '[' bound=Unsigned_Int ']' )? ( ASSIGNMENT initialValue=D_Byte_Char_Str )?;
		////Loc_Partly_Var_Decl : {Loc_Partly_Var_Decl} 'VAR' modifier=( 'RETAIN' | 'NON_RETAIN' )? variables+=Loc_Partly_Var * 'END_VAR';
		////Loc_Partly_Var : name=IDENTIFIER 'AT' '%' locationPrefix=( 'I' | 'Q' | 'M' ) '*' ':' initialization=Var_Spec ';';
		////Var_Spec : Simple_Spec | Array_Spec | Qualified_Name | StringVar_Spec;
		////StringVar_Spec: type=( 'STRING' | 'WSTRING' ) ( '[' bound=Unsigned_Int ']' )?;
		////
		////// Table 19 - Function declaration
		////Func_Name : Std_Func_Name | IDENTIFIER;
		////Std_Func_Name : 'TRUNC' | 'ABS' | 'SQRT' | 'LN' | 'LOG' | 'EXP' | 
		////	'SIN' | 'COS' | 'TAN' | 'ASIN' | 'ACOS' | 'ATAN' | 'ATAN2 ' | 
		////	'ADD' | 'SUB' | 'MUL' | 'DIV' | 'MOD' | 'EXPT' | 'MOVE ' | 
		////	'SHL' | 'SHR' | 'ROL' | 'ROR' | 'AND' | 'OR'  | 'XOR' | 'NOT' | 
		////	'SEL' | 'MAX' | 'MIN' | 'LIMIT' | 'MUX ' | 'GT' | 'GE' | 'EQ' | 
		////	'LE' | 'LT' | 'NE' | 'LEN' | 'LEFT' | 'RIGHT' | 'MID' | 'CONCAT' | 
		////	'INSERT' | 'DELETE' | 'REPLACE' | 'FIND';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: complete list above ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Func_Decl : 'FUNCTION' name=IDENTIFIER ( ':' returnType=Data_Type_Access )? usings+=Using_Directive* ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
		////		'END_FUNCTION';
		////IO_Var_Decls : Input_Decls | Output_Decls | In_Out_Decls;
		////Func_Var_Decls : External_Var_Decls | Var_Decls;
		////
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: other languages on list below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Func_Body : / *Ladder_Diagram | FB_Diagram | Instruction_List |* / Stmt_List;// | Other_Languages;
		////
		////
		////// Table 40 – Function block type declaration
		////
		////// Table 41 - Function block instance declaration
		////FB_Type_Name : Std_FB_Name | IDENTIFIER;
		////FB_Type_Access : Qualified_Prefix FB_Type_Name | FB_Type_Name;
		////Std_FB_Name : 'SR' | 'RS' | 'R_TRIG' | 'F_TRIG' | 'CTU'| 'CTD' | 'CTUD' | 'TP' | 'TON' | 'TOF';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: complete list above ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////FB_Decl : 'FUNCTION_BLOCK' modifier=( 'FINAL' | 'ABSTRACT' )? name=IDENTIFIER usings+=Using_Directive* ( 'EXTENDS' extends=( FB_Type_Access | Qualified_Name ) )?
		////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( ios+=FB_IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls )*
		////	( methods+=Method_Decl )* body=FB_Body ? 
		////	'END_FUNCTION_BLOCK';
		////FB_IO_Var_Decls : FB_Input_Decls | FB_Output_Decls | In_Out_Decls;
		////FB_Input_Decls : {FB_Input_Decls} 'VAR_INPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Input_Decl ';' )* 'END_VAR';
		////FB_Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
		////FB_Output_Decls : {FB_Output_Decls} 'VAR_OUTPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Output_Decl ';' )* 'END_VAR';
		////FB_Output_Decl : Var_Decl_Init | Array_Conform_Decl;
		////Other_Var_Decls : Retain_Var_Decls | No_Retain_Var_Decls | Loc_Partly_Var_Decl;
		////No_Retain_Var_Decls : {No_Retain_Var_Decls} 'VAR' 'NON_RETAIN' access=Access_Spec ? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: other languages on list below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////FB_Body : Stmt_List; //| SFC | Ladder_Diagram | FB_Diagram | Instruction_List | Other_Languages;
		////Method_Decl : 'METHOD' access=Access_Spec type=( 'FINAL' | 'ABSTRACT' )? override?='OVERRIDE'?
		////	name=IDENTIFIER ( ':' returnType=Data_Type_Access )? ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
		////	'END_METHOD';
		////
		////// Table 48 - Class
		////
		////// Table 50 Textual call of methods – Formal and non-formal parameter list
		////Class_Decl : 'CLASS' modifier=( 'FINAL' | 'ABSTRACT' )? name=IDENTIFIER usings+=Using_Directive* ( 'EXTENDS' extends=Qualified_Name )? 
		////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( variables+=Func_Var_Decls | others+=Other_Var_Decls )* ( methods+=Method_Decl )* 
		////	'END_CLASS';
		////Class_Instance_Name : Qualified_Name '^' *;
		////Interface_Decl : 'INTERFACE' name=IDENTIFIER usings+=Using_Directive* 
		////	( 'EXTENDS' extends+=Interface_Name_List )? 
		////	methods+=Method_Prototype* 
		////	'END_INTERFACE';
		////Method_Prototype : 'METHOD' name=IDENTIFIER ( ':' returnType=Data_Type_Access )? ios+=IO_Var_Decls* 
		////	'END_METHOD';
		////Interface_Spec_Init : variables=Variable_List ( ASSIGNMENT initialization=Interface_Value )?;
		////Interface_Value : ((variable=Symbolic_Variable) | variableName=(FB_Instance_Name | Class_Instance_Name | 'NULL'));
		////Interface_Name_List : interfaces+=Qualified_Name ( ',' interfaces+=Qualified_Name )*;
		////Access_Spec : 'PUBLIC' | 'PROTECTED' | 'PRIVATE' | 'INTERNAL';
		////
		////// Table 47 - Program declaration
		////Prog_Decl : 'PROGRAM' name=IDENTIFIER
		////	( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls | locals+=Loc_Var_Decls | acesses+=Prog_Access_Decls )* 
		////body=FB_Body 'END_PROGRAM';
		////Prog_Access_Decls : {Prog_Access_Decls} 'VAR_ACCESS' ( accesses+=Prog_Access_Decl ';' )* 'END_VAR';
		////Prog_Access_Decl : name=IDENTIFIER ':' variable=Symbolic_Variable access=Multibit_Part_Access? ':' dataType=Data_Type_Access direction=Access_Direction?;
		////
		////// Table 62 - Configuration and resource declaration
		//////Config_Decl : 'CONFIGURATION' Config_Name Global_Var_Decls ?
		//////( Single_Resource_Decl | Resource_Decl + ) Access_Decls ? Config_Init ?
		//////'END_CONFIGURATION';
		//////Resource_Decl : 'RESOURCE' Resource_Name 'ON' Resource_Type_Name
		//////Global_Var_Decls ? Single_Resource_Decl
		//////'END_RESOURCE';
		//////Single_Resource_Decl : ( Task_Config ';' )* ( Prog_Config ';' )+;
		//////Access_Decls : 'VAR_ACCESS' ( Access_Decl ';' )* 'END_VAR';
		//////Access_Decl : IDENTIFIER ':' Access_Path ':' Data_Type_Access Access_Direction ?;
		//////Access_Path : ( Resource_Name Dot )? Direct_Variable
		//////| ( Resource_Name Dot )? ( Prog_Name Dot )?
		//////( ( FB_Instance_Name | Class_Instance_Name ) Dot )* Symbolic_Variable;
		//////Global_Var_Access : ( Resource_Name Dot )? IDENTIFIER ( Dot Struct_Elem_Name )?;
		//////Prog_Output_Access : Prog_Name Dot Symbolic_Variable;
		////Access_Direction : 'READ_WRITE' | 'READ_ONLY';
		//////Task_Config : 'TASK' Task_Name Task_Init;
		//////Task_Init : '(' ( 'SINGLE' ASSIGNMENT Data_Source ',' )?
		//////( 'INTERVAL' ASSIGNMENT Data_Source ',' )?
		//////'PRIORITY' ASSIGNMENT Unsigned_Int ')';
		//////Data_Source : Constant | Global_Var_Access | Prog_Output_Access | Direct_Variable;
		//////Prog_Config : 'PROGRAM' ( 'RETAIN' | 'NON_RETAIN' )? Prog_Name ( 'WITH' Task_Name )? ':'
		//////Prog_Type_Access ( '(' Prog_Conf_Elems ')' )?;
		//////Prog_Conf_Elems : Prog_Conf_Elem ( ',' Prog_Conf_Elem )*;
		//////Prog_Conf_Elem : FB_Task | Prog_Cnxn;
		//////FB_Task : FB_Instance_Name 'WITH' Task_Name;
		//////Prog_Cnxn : Symbolic_Variable ASSIGNMENT Prog_Data_Source | Symbolic_Variable '=>' Data_Sink;
		//////Prog_Data_Source : Constant | Enum_Value | Global_Var_Access | Direct_Variable;
		//////Data_Sink : Global_Var_Access | Direct_Variable;
		//////Config_Init : 'VAR_CONFIG' ( Config_Inst_Init ';' )* 'END_VAR';
		//////Config_Inst_Init : Resource_Name Dot Prog_Name Dot ( ( FB_Instance_Name | Class_Instance_Name ) Dot )*
		//////( IDENTIFIER Located_At ? ':' Loc_Var_Spec_Init
		//////| ( ( FB_Instance_Name ':' FB_Type_Access )
		//////| ( Class_Instance_Name ':' Qualified_Name ) ) ASSIGNMENT Struct_Init );
		//////
		//////// Table 64 - Namespace
		//////Namespace_Decl : 'NAMESPACE' 'INTERNAL' ? Namespace_H_Name Using_Directive * Namespace_Elements
		//////'END_NAMESPACE';
		//////Namespace_Elements : ( Data_Type_Decl | Func_Decl | FB_Decl
		//////| Class_Decl | Interface_Decl | Namespace_Decl )+;
		////Using_Directive : 'USING' namespaces+=Qualified_Name ( ',' namespaces+=Qualified_Name )* ';';
		//////POU_Decl : Using_Directive *
		//////( Global_Var_Decls | Data_Type_Decl | Access_Decls
		//////| Func_Decl | FB_Decl | Class_Decl | Interface_Decl
		//////| Namespace_Decl )+;
		//////
		////
		////// Table 71 - 72 - Language Structured Text (ST)
		////Expression returns Expression: Xor_Expr ({Expression.left=current} operator='OR' right=Xor_Expr )*;
		////// a constant expression must evaluate to a constant value at compile time
		////Constant_Expr : Expression;
		////Xor_Expr returns Expression: And_Expr ({Xor_Expr.left=current} operator='XOR' right=And_Expr )*;
		////And_Expr returns Expression: Compare_Expr ({And_Expr.left=current} operator=( '&' | 'AND' ) right=Compare_Expr )*;
		////Compare_Expr returns Expression: Equ_Expr ({Compare_Expr.left=current} operator=( '=' | '<>' ) right=Equ_Expr )*;
		////Equ_Expr returns Expression: Add_Expr ({Equ_Expr.left=current} operator=( '<' | '>' | '<=' | '>=' ) right=Add_Expr )*;
		////Add_Expr returns Expression: Term ({Add_Expr.left=current} operator=Number_Sign right=Term )*;
		////Term returns Expression: Power_Expr ({Term.left=current} operator=('*' | '/' | 'MOD') right=Power_Expr )*;
		////Power_Expr returns Expression: Unary_Expr ({Power_Expr.left=current} operator='**' right=Unary_Expr )*;
		////Unary_Expr returns Expression: operator=('-' | '+' | 'NOT')? expression=Primary_Expr;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call |  Ref_Value | '(' Expression ')'^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Primary_Expr returns Expression: {Expression} Constant | Enum_Value | Variable_Access / * | Func_Call |  Ref_Value | '(' Expression ')' * /;
		////
		////Variable_Access : variable=Variable access=Multibit_Part_Access ?;
		////Multibit_Part_Access : Dot ( accessSize=Unsigned_Int | accessSizeInfo=Size_Info );
		////Size_Info : '%' sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' ) ? size=Unsigned_Int;
		////Func_Call : access=Qualified_Name '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////Stmt_List : {Stmt_List} ( statement+=Stmt ? ';' )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Assign_Stmt | Subprog_Ctrl_Stmt |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Stmt : / * Assign_Stmt | Subprog_Ctrl_Stmt | * / Selection_Stmt | Iteration_Stmt;
		////Assign_Stmt : Variable_Assign_Stmt | Ref_Assign | Assignment_Attempt;
		////Variable_Assign_Stmt : left=Variable ASSIGNMENT right=Expression;
		////Assignment_Attempt : ( leftName=IDENTIFIER | leftReference=Ref_Deref ) '?=' ( rightName=IDENTIFIER | rightReference=(Ref_Deref | Ref_Value) );
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below | Qualified_Method_Call^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Invocation : method=( FB_Instance_Name | IDENTIFIER | 'THIS' / * | Qualified_Method_Call * / ) '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////// Qualified_Method_Call : ( ( 'THIS' Dot )? ( ( ( FB_Instance_Name | Class_Instance_Name ) Dot )+ ) IDENTIFIER );
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Subprog_Ctrl_Stmt : / * Func_Call | Invocation | * / Super_Invocation | Return;
		////Sub_Invocation: Super_Invocation | Return;
		////Super_Invocation : 'SUPER' '(' ')';
		////Return : 'RETURN';
		////Param_Assign : Named_Value | Ref_Assign | Linked_Value;
		////Named_Value : ( name=IDENTIFIER ASSIGNMENT )? value=Expression;
		////Linked_Value : (negated?='NOT')? name=IDENTIFIER '=>' value=Variable;
		////Selection_Stmt : IF_Stmt | Case_Stmt;
		////IF_Stmt : 'IF' condition=Expression 'THEN' statements=Stmt_List ( elseifs+=ELSEIF_Stmt )* ( else=ELSE_Stmt )? 'END_IF';
		////ELSEIF_Stmt : 'ELSIF' condition=Expression 'THEN' statements=Stmt_List;
		////ELSE_Stmt: 'ELSE' statements=Stmt_List;
		////Case_Stmt : 'CASE' expression=Expression 'OF' cases+=Case_Selection + ( 'ELSE' defaultStatements=Stmt_List )? 'END_CASE';
		////Case_Selection : values=Case_List ':' statements=Stmt_List;
		////Case_List : caseValues+=Case_List_Elem ( ',' caseValues+=Case_List_Elem )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Case_List_Elem : Subrange / *| Constant_Expr* /;
		////Iteration_Stmt : For_Stmt | While_Stmt | Repeat_Stmt | Exit_Stmt | Continue_Stmt;
		////Exit_Stmt : {Exit_Stmt} 'EXIT';
		////Continue_Stmt : {Continue_Stmt} 'CONTINUE';
		////For_Stmt : 'FOR' variable=IDENTIFIER ASSIGNMENT bounds=For_List 'DO' statements=Stmt_List 'END_FOR';
		////For_List : lowBound=Expression 'TO' upBound=Expression ( 'BY' step=Expression )?;
		////While_Stmt : 'WHILE' condition=Expression 'DO' statements=Stmt_List 'END_WHILE';
		////Repeat_Stmt : 'REPEAT' statements=Stmt_List 'UNTIL' condition=Expression 'END_REPEAT'; DAYTIME_VALUE
		public RuleCall getDAYTIME_VALUETerminalRuleCall_4() { return cDAYTIME_VALUETerminalRuleCall_4; }
	}
	
	
	private TestElements pTest;
	private TerminalRule tLETTER;
	private TerminalRule tBIT;
	private TerminalRule tOCTAL_DIGIT;
	private TerminalRule tDIGIT;
	private TerminalRule tHEX_DIGIT;
	private TerminalRule tIDENTIFIER;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tML_COMMENT_1;
	private TerminalRule tML_COMMENT_2;
	private TerminalRule tWS;
	private TerminalRule tEOL;
	private TerminalRule tPRAGMA;
	private TerminalRule tBIN_VALUE;
	private TerminalRule tOCT_VALUE;
	private TerminalRule tHEX_VALUE;
	private TerminalRule tDEC_VALUE;
	private TerminalRule tFIX_POINT;
	private TerminalRule tFLOAT_VALUE;
	private ConstantElements pConstant;
	private Numeric_LiteralElements pNumeric_Literal;
	private Int_LiteralElements pInt_Literal;
	private Int_Type_NameElements pInt_Type_Name;
	private Unsigned_Int_Type_NameElements pUnsigned_Int_Type_Name;
	private Signed_Int_Type_NameElements pSigned_Int_Type_Name;
	private Unsigned_IntElements pUnsigned_Int;
	private Unsigned_Int_ValueElements pUnsigned_Int_Value;
	private Signed_IntElements pSigned_Int;
	private Signed_Int_ValueElements pSigned_Int_Value;
	private Real_LiteralElements pReal_Literal;
	private Real_Type_NameElements pReal_Type_Name;
	private Real_ValueElements pReal_Value;
	private Bit_Str_LiteralElements pBit_Str_Literal;
	private Multibits_Type_NameElements pMultibits_Type_Name;
	private Bit_Str_ValueElements pBit_Str_Value;
	private Bool_LiteralElements pBool_Literal;
	private Bool_ValueElements pBool_Value;
	private Bool_Type_NameElements pBool_Type_Name;
	private Char_LiteralElements pChar_Literal;
	private Char_ValueElements pChar_Value;
	private Char_StrElements pChar_Str;
	private S_Byte_Char_StrElements pS_Byte_Char_Str;
	private D_Byte_Char_StrElements pD_Byte_Char_Str;
	private TerminalRule tS_BYTE_CHAR_VALUE;
	private TerminalRule tD_BYTE_CHAR_VALUE;
	private TerminalRule tCOMMON_CHAR_VALUE;
	private Time_Type_NameElements pTime_Type_Name;
	private Tod_Type_NameElements pTod_Type_Name;
	private Date_Type_NameElements pDate_Type_Name;
	private Dt_Type_NameElements pDt_Type_Name;
	private Time_LiteralElements pTime_Literal;
	private DurationElements pDuration;
	private Duration_ValueElements pDuration_Value;
	private TerminalRule tINTERVAL;
	private TerminalRule tDAYS;
	private TerminalRule tHOURS;
	private TerminalRule tMINUTES;
	private TerminalRule tSECONDS;
	private TerminalRule tMILLISECONDS;
	private TerminalRule tMICROSECONDS;
	private TerminalRule tNANOSECONDS;
	private Time_Of_DayElements pTime_Of_Day;
	private Time_Of_Day_ValueElements pTime_Of_Day_Value;
	private DaytimeElements pDaytime;
	private TerminalRule tDAYTIME_VALUE;
	private DateElements pDate;
	private TerminalRule tDATE_VALUE;
	private TerminalRule tDATE_LITERAL;
	private Date_And_TimeElements pDate_And_Time;
	private Date_And_Time_ValueElements pDate_And_Time_Value;
	
	private final Grammar grammar;

	@Inject
	public STLanguageGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("at.bachmann.plc.st.STLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//test:
	//	test="t";
	public TestElements getTestAccess() {
		return (pTest != null) ? pTest : (pTest = new TestElements());
	}
	
	public ParserRule getTestRule() {
		return getTestAccess().getRule();
	}

	////ST_Program: Prog_Decl;
	//// Table 1 - Character sets
	//// Table 2 - Identifiers
	//terminal fragment LETTER:
	//	"A".."Z" | "a".."z" | "_";
	public TerminalRule getLETTERRule() {
		return (tLETTER != null) ? tLETTER : (tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LETTER"));
	} 

	//terminal fragment BIT:
	//	"0".."1";
	public TerminalRule getBITRule() {
		return (tBIT != null) ? tBIT : (tBIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BIT"));
	} 

	//terminal fragment OCTAL_DIGIT:
	//	"0".."7";
	public TerminalRule getOCTAL_DIGITRule() {
		return (tOCTAL_DIGIT != null) ? tOCTAL_DIGIT : (tOCTAL_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OCTAL_DIGIT"));
	} 

	//terminal fragment DIGIT:
	//	"0".."9";
	public TerminalRule getDIGITRule() {
		return (tDIGIT != null) ? tDIGIT : (tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT"));
	} 

	//terminal fragment HEX_DIGIT:
	//	"0".."9" | "A".."F";
	public TerminalRule getHEX_DIGITRule() {
		return (tHEX_DIGIT != null) ? tHEX_DIGIT : (tHEX_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX_DIGIT"));
	} 

	//terminal IDENTIFIER:
	//	LETTER (LETTER | DIGIT)*;
	public TerminalRule getIDENTIFIERRule() {
		return (tIDENTIFIER != null) ? tIDENTIFIER : (tIDENTIFIER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "IDENTIFIER"));
	} 

	//// Table 3 - Comments
	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* "\r"? "\n";
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal ML_COMMENT_1:
	//	"(*"->"*)";
	public TerminalRule getML_COMMENT_1Rule() {
		return (tML_COMMENT_1 != null) ? tML_COMMENT_1 : (tML_COMMENT_1 = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT_1"));
	} 

	//terminal ML_COMMENT_2:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENT_2Rule() {
		return (tML_COMMENT_2 != null) ? tML_COMMENT_2 : (tML_COMMENT_2 = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT_2"));
	} 

	//// white space
	//terminal fragment WS:
	//	" " | "\t" | "\r" | "\n";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal fragment EOL:
	//	"\n";
	public TerminalRule getEOLRule() {
		return (tEOL != null) ? tEOL : (tEOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EOL"));
	} 

	//// Table 4 - Pragma
	//terminal PRAGMA:
	//	"{"->"}";
	public TerminalRule getPRAGMARule() {
		return (tPRAGMA != null) ? tPRAGMA : (tPRAGMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PRAGMA"));
	} 

	//// Table 5 - Numeric literal
	//terminal BIN_VALUE:
	//	"2#" ("_"? BIT)+;
	public TerminalRule getBIN_VALUERule() {
		return (tBIN_VALUE != null) ? tBIN_VALUE : (tBIN_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BIN_VALUE"));
	} 

	//terminal OCT_VALUE:
	//	"8#" ("_"? OCTAL_DIGIT)+;
	public TerminalRule getOCT_VALUERule() {
		return (tOCT_VALUE != null) ? tOCT_VALUE : (tOCT_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OCT_VALUE"));
	} 

	//terminal HEX_VALUE:
	//	"16#" ("_"? HEX_DIGIT)+;
	public TerminalRule getHEX_VALUERule() {
		return (tHEX_VALUE != null) ? tHEX_VALUE : (tHEX_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX_VALUE"));
	} 

	//terminal DEC_VALUE:
	//	DIGIT (DIGIT | "_" DIGIT)*;
	public TerminalRule getDEC_VALUERule() {
		return (tDEC_VALUE != null) ? tDEC_VALUE : (tDEC_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DEC_VALUE"));
	} 

	//terminal fragment FIX_POINT:
	//	DEC_VALUE "." DEC_VALUE;
	public TerminalRule getFIX_POINTRule() {
		return (tFIX_POINT != null) ? tFIX_POINT : (tFIX_POINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FIX_POINT"));
	} 

	//terminal FLOAT_VALUE:
	//	FIX_POINT (("E" | "e") ("+" | "-")? DEC_VALUE)?;
	public TerminalRule getFLOAT_VALUERule() {
		return (tFLOAT_VALUE != null) ? tFLOAT_VALUE : (tFLOAT_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FLOAT_VALUE"));
	} 

	//Constant:
	//	Numeric_Literal | Char_Literal | Time_Literal | Bit_Str_Literal | Bool_Literal;
	public ConstantElements getConstantAccess() {
		return (pConstant != null) ? pConstant : (pConstant = new ConstantElements());
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	//Numeric_Literal:
	//	Int_Literal | Real_Literal;
	public Numeric_LiteralElements getNumeric_LiteralAccess() {
		return (pNumeric_Literal != null) ? pNumeric_Literal : (pNumeric_Literal = new Numeric_LiteralElements());
	}
	
	public ParserRule getNumeric_LiteralRule() {
		return getNumeric_LiteralAccess().getRule();
	}

	//Int_Literal:
	//	Signed_Int | Unsigned_Int;
	public Int_LiteralElements getInt_LiteralAccess() {
		return (pInt_Literal != null) ? pInt_Literal : (pInt_Literal = new Int_LiteralElements());
	}
	
	public ParserRule getInt_LiteralRule() {
		return getInt_LiteralAccess().getRule();
	}

	//Int_Type_Name:
	//	Signed_Int_Type_Name | Unsigned_Int_Type_Name;
	public Int_Type_NameElements getInt_Type_NameAccess() {
		return (pInt_Type_Name != null) ? pInt_Type_Name : (pInt_Type_Name = new Int_Type_NameElements());
	}
	
	public ParserRule getInt_Type_NameRule() {
		return getInt_Type_NameAccess().getRule();
	}

	//Unsigned_Int_Type_Name:
	//	"USINT" | "UINT" | "UDINT" | "ULINT";
	public Unsigned_Int_Type_NameElements getUnsigned_Int_Type_NameAccess() {
		return (pUnsigned_Int_Type_Name != null) ? pUnsigned_Int_Type_Name : (pUnsigned_Int_Type_Name = new Unsigned_Int_Type_NameElements());
	}
	
	public ParserRule getUnsigned_Int_Type_NameRule() {
		return getUnsigned_Int_Type_NameAccess().getRule();
	}

	//Signed_Int_Type_Name:
	//	"SINT" | "INT" | "DINT" | "LINT";
	public Signed_Int_Type_NameElements getSigned_Int_Type_NameAccess() {
		return (pSigned_Int_Type_Name != null) ? pSigned_Int_Type_Name : (pSigned_Int_Type_Name = new Signed_Int_Type_NameElements());
	}
	
	public ParserRule getSigned_Int_Type_NameRule() {
		return getSigned_Int_Type_NameAccess().getRule();
	}

	//Unsigned_Int:
	//	value=Unsigned_Int_Value;
	public Unsigned_IntElements getUnsigned_IntAccess() {
		return (pUnsigned_Int != null) ? pUnsigned_Int : (pUnsigned_Int = new Unsigned_IntElements());
	}
	
	public ParserRule getUnsigned_IntRule() {
		return getUnsigned_IntAccess().getRule();
	}

	//Unsigned_Int_Value:
	//	Unsigned_Int_Type_Name (BIN_VALUE | OCT_VALUE | DEC_VALUE | HEX_VALUE);
	public Unsigned_Int_ValueElements getUnsigned_Int_ValueAccess() {
		return (pUnsigned_Int_Value != null) ? pUnsigned_Int_Value : (pUnsigned_Int_Value = new Unsigned_Int_ValueElements());
	}
	
	public ParserRule getUnsigned_Int_ValueRule() {
		return getUnsigned_Int_ValueAccess().getRule();
	}

	//Signed_Int:
	//	value=Signed_Int_Value;
	public Signed_IntElements getSigned_IntAccess() {
		return (pSigned_Int != null) ? pSigned_Int : (pSigned_Int = new Signed_IntElements());
	}
	
	public ParserRule getSigned_IntRule() {
		return getSigned_IntAccess().getRule();
	}

	//Signed_Int_Value:
	//	Signed_Int_Type_Name (BIN_VALUE | OCT_VALUE | ("+" | "-")? DEC_VALUE | HEX_VALUE);
	public Signed_Int_ValueElements getSigned_Int_ValueAccess() {
		return (pSigned_Int_Value != null) ? pSigned_Int_Value : (pSigned_Int_Value = new Signed_Int_ValueElements());
	}
	
	public ParserRule getSigned_Int_ValueRule() {
		return getSigned_Int_ValueAccess().getRule();
	}

	//Real_Literal:
	//	value=Real_Value;
	public Real_LiteralElements getReal_LiteralAccess() {
		return (pReal_Literal != null) ? pReal_Literal : (pReal_Literal = new Real_LiteralElements());
	}
	
	public ParserRule getReal_LiteralRule() {
		return getReal_LiteralAccess().getRule();
	}

	//Real_Type_Name:
	//	"LREAL" | "REAL";
	public Real_Type_NameElements getReal_Type_NameAccess() {
		return (pReal_Type_Name != null) ? pReal_Type_Name : (pReal_Type_Name = new Real_Type_NameElements());
	}
	
	public ParserRule getReal_Type_NameRule() {
		return getReal_Type_NameAccess().getRule();
	}

	//Real_Value:
	//	Real_Type_Name ("+" | "-")? FLOAT_VALUE;
	public Real_ValueElements getReal_ValueAccess() {
		return (pReal_Value != null) ? pReal_Value : (pReal_Value = new Real_ValueElements());
	}
	
	public ParserRule getReal_ValueRule() {
		return getReal_ValueAccess().getRule();
	}

	//Bit_Str_Literal:
	//	value=Bit_Str_Value;
	public Bit_Str_LiteralElements getBit_Str_LiteralAccess() {
		return (pBit_Str_Literal != null) ? pBit_Str_Literal : (pBit_Str_Literal = new Bit_Str_LiteralElements());
	}
	
	public ParserRule getBit_Str_LiteralRule() {
		return getBit_Str_LiteralAccess().getRule();
	}

	//Multibits_Type_Name:
	//	"BYTE" | "WORD" | "DWORD" | "LWORD";
	public Multibits_Type_NameElements getMultibits_Type_NameAccess() {
		return (pMultibits_Type_Name != null) ? pMultibits_Type_Name : (pMultibits_Type_Name = new Multibits_Type_NameElements());
	}
	
	public ParserRule getMultibits_Type_NameRule() {
		return getMultibits_Type_NameAccess().getRule();
	}

	//Bit_Str_Value:
	//	Multibits_Type_Name "#" (BIN_VALUE | OCT_VALUE | DEC_VALUE | HEX_VALUE);
	public Bit_Str_ValueElements getBit_Str_ValueAccess() {
		return (pBit_Str_Value != null) ? pBit_Str_Value : (pBit_Str_Value = new Bit_Str_ValueElements());
	}
	
	public ParserRule getBit_Str_ValueRule() {
		return getBit_Str_ValueAccess().getRule();
	}

	//Bool_Literal:
	//	value=Bool_Value;
	public Bool_LiteralElements getBool_LiteralAccess() {
		return (pBool_Literal != null) ? pBool_Literal : (pBool_Literal = new Bool_LiteralElements());
	}
	
	public ParserRule getBool_LiteralRule() {
		return getBool_LiteralAccess().getRule();
	}

	//Bool_Value:
	//	(Bool_Type_Name "#")? ("0" | "1" | "FALSE" | "TRUE");
	public Bool_ValueElements getBool_ValueAccess() {
		return (pBool_Value != null) ? pBool_Value : (pBool_Value = new Bool_ValueElements());
	}
	
	public ParserRule getBool_ValueRule() {
		return getBool_ValueAccess().getRule();
	}

	//Bool_Type_Name:
	//	"BOOL";
	public Bool_Type_NameElements getBool_Type_NameAccess() {
		return (pBool_Type_Name != null) ? pBool_Type_Name : (pBool_Type_Name = new Bool_Type_NameElements());
	}
	
	public ParserRule getBool_Type_NameRule() {
		return getBool_Type_NameAccess().getRule();
	}

	//// Table 6 - Character String literals
	//// Table 7 - Two-character combinations in character strings
	//Char_Literal:
	//	value=Char_Value;
	public Char_LiteralElements getChar_LiteralAccess() {
		return (pChar_Literal != null) ? pChar_Literal : (pChar_Literal = new Char_LiteralElements());
	}
	
	public ParserRule getChar_LiteralRule() {
		return getChar_LiteralAccess().getRule();
	}

	//Char_Value:
	//	"STRING#"? Char_Str;
	public Char_ValueElements getChar_ValueAccess() {
		return (pChar_Value != null) ? pChar_Value : (pChar_Value = new Char_ValueElements());
	}
	
	public ParserRule getChar_ValueRule() {
		return getChar_ValueAccess().getRule();
	}

	//Char_Str:
	//	S_Byte_Char_Str | D_Byte_Char_Str;
	public Char_StrElements getChar_StrAccess() {
		return (pChar_Str != null) ? pChar_Str : (pChar_Str = new Char_StrElements());
	}
	
	public ParserRule getChar_StrRule() {
		return getChar_StrAccess().getRule();
	}

	//S_Byte_Char_Str:
	//	"\'" S_BYTE_CHAR_VALUE+ "\'";
	public S_Byte_Char_StrElements getS_Byte_Char_StrAccess() {
		return (pS_Byte_Char_Str != null) ? pS_Byte_Char_Str : (pS_Byte_Char_Str = new S_Byte_Char_StrElements());
	}
	
	public ParserRule getS_Byte_Char_StrRule() {
		return getS_Byte_Char_StrAccess().getRule();
	}

	//D_Byte_Char_Str:
	//	"\"" D_BYTE_CHAR_VALUE+ "\"";
	public D_Byte_Char_StrElements getD_Byte_Char_StrAccess() {
		return (pD_Byte_Char_Str != null) ? pD_Byte_Char_Str : (pD_Byte_Char_Str = new D_Byte_Char_StrElements());
	}
	
	public ParserRule getD_Byte_Char_StrRule() {
		return getD_Byte_Char_StrAccess().getRule();
	}

	//terminal S_BYTE_CHAR_VALUE:
	//	COMMON_CHAR_VALUE | "$\'" | "\"" | "$" HEX_DIGIT HEX_DIGIT;
	public TerminalRule getS_BYTE_CHAR_VALUERule() {
		return (tS_BYTE_CHAR_VALUE != null) ? tS_BYTE_CHAR_VALUE : (tS_BYTE_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "S_BYTE_CHAR_VALUE"));
	} 

	//terminal D_BYTE_CHAR_VALUE:
	//	COMMON_CHAR_VALUE | "\'" | "$\"" | "$" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
	public TerminalRule getD_BYTE_CHAR_VALUERule() {
		return (tD_BYTE_CHAR_VALUE != null) ? tD_BYTE_CHAR_VALUE : (tD_BYTE_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "D_BYTE_CHAR_VALUE"));
	} 

	//// any printable characters except $, " and '
	//terminal fragment COMMON_CHAR_VALUE:
	//	" " | "!" | "#" | "%" | "&" | "(".."/" | "0".."9" | ":".."@" | "A".."Z" | "[".."`" | "a".."z" | "{".."~" | "$$" |
	//	"$L" | "$N" | "$P" | "$R" | "$T";
	public TerminalRule getCOMMON_CHAR_VALUERule() {
		return (tCOMMON_CHAR_VALUE != null) ? tCOMMON_CHAR_VALUE : (tCOMMON_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMON_CHAR_VALUE"));
	} 

	//// Table 8 - Duration literals
	//// Table 9 – Date and time of day literals
	//Time_Type_Name:
	//	"TIME" | "LTIME";
	public Time_Type_NameElements getTime_Type_NameAccess() {
		return (pTime_Type_Name != null) ? pTime_Type_Name : (pTime_Type_Name = new Time_Type_NameElements());
	}
	
	public ParserRule getTime_Type_NameRule() {
		return getTime_Type_NameAccess().getRule();
	}

	//Tod_Type_Name:
	//	"TIME_OF_DAY" | "TOD" | "LTOD";
	public Tod_Type_NameElements getTod_Type_NameAccess() {
		return (pTod_Type_Name != null) ? pTod_Type_Name : (pTod_Type_Name = new Tod_Type_NameElements());
	}
	
	public ParserRule getTod_Type_NameRule() {
		return getTod_Type_NameAccess().getRule();
	}

	//Date_Type_Name:
	//	"DATE" | "LDATE";
	public Date_Type_NameElements getDate_Type_NameAccess() {
		return (pDate_Type_Name != null) ? pDate_Type_Name : (pDate_Type_Name = new Date_Type_NameElements());
	}
	
	public ParserRule getDate_Type_NameRule() {
		return getDate_Type_NameAccess().getRule();
	}

	//Dt_Type_Name:
	//	"DATE_AND_TIME" | "DT" | "LDT";
	public Dt_Type_NameElements getDt_Type_NameAccess() {
		return (pDt_Type_Name != null) ? pDt_Type_Name : (pDt_Type_Name = new Dt_Type_NameElements());
	}
	
	public ParserRule getDt_Type_NameRule() {
		return getDt_Type_NameAccess().getRule();
	}

	//Time_Literal:
	//	Duration | Time_Of_Day | Date | Date_And_Time;
	public Time_LiteralElements getTime_LiteralAccess() {
		return (pTime_Literal != null) ? pTime_Literal : (pTime_Literal = new Time_LiteralElements());
	}
	
	public ParserRule getTime_LiteralRule() {
		return getTime_LiteralAccess().getRule();
	}

	//Duration:
	//	value=Duration_Value;
	public DurationElements getDurationAccess() {
		return (pDuration != null) ? pDuration : (pDuration = new DurationElements());
	}
	
	public ParserRule getDurationRule() {
		return getDurationAccess().getRule();
	}

	//Duration_Value:
	//	(Time_Type_Name | "T" | "LT") "#" ("+" | "-")? INTERVAL;
	public Duration_ValueElements getDuration_ValueAccess() {
		return (pDuration_Value != null) ? pDuration_Value : (pDuration_Value = new Duration_ValueElements());
	}
	
	public ParserRule getDuration_ValueRule() {
		return getDuration_ValueAccess().getRule();
	}

	//terminal INTERVAL:
	//	DAYS? HOURS? MINUTES? SECONDS? MILLISECONDS? MICROSECONDS? NANOSECONDS?;
	public TerminalRule getINTERVALRule() {
		return (tINTERVAL != null) ? tINTERVAL : (tINTERVAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INTERVAL"));
	} 

	//terminal fragment DAYS:
	//	FIX_POINT ("d" | "D") | DEC_VALUE ("d" | "D") "_"?;
	public TerminalRule getDAYSRule() {
		return (tDAYS != null) ? tDAYS : (tDAYS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAYS"));
	} 

	//terminal fragment HOURS:
	//	FIX_POINT ("h" | "H") | DEC_VALUE ("h" | "H") "_"?;
	public TerminalRule getHOURSRule() {
		return (tHOURS != null) ? tHOURS : (tHOURS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HOURS"));
	} 

	//terminal fragment MINUTES:
	//	FIX_POINT ("m" | "M") | DEC_VALUE ("m" | "M") "_"?;
	public TerminalRule getMINUTESRule() {
		return (tMINUTES != null) ? tMINUTES : (tMINUTES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINUTES"));
	} 

	//terminal fragment SECONDS:
	//	FIX_POINT ("s" | "S") | DEC_VALUE ("s" | "S") "_"?;
	public TerminalRule getSECONDSRule() {
		return (tSECONDS != null) ? tSECONDS : (tSECONDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SECONDS"));
	} 

	//terminal fragment MILLISECONDS:
	//	FIX_POINT ("ms" | "Ms" | "mS" | "MS") | DEC_VALUE ("ms" | "Ms" | "mS" | "MS") "_"?;
	public TerminalRule getMILLISECONDSRule() {
		return (tMILLISECONDS != null) ? tMILLISECONDS : (tMILLISECONDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MILLISECONDS"));
	} 

	//terminal fragment MICROSECONDS:
	//	FIX_POINT ("u" | "U") ("s" | "S") | DEC_VALUE (("u" | "U") ("s" | "S")) "_"?;
	public TerminalRule getMICROSECONDSRule() {
		return (tMICROSECONDS != null) ? tMICROSECONDS : (tMICROSECONDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MICROSECONDS"));
	} 

	//terminal fragment NANOSECONDS:
	//	FIX_POINT ("n" | "N") ("s" | "S") | DEC_VALUE (("n" | "N") ("s" | "S"));
	public TerminalRule getNANOSECONDSRule() {
		return (tNANOSECONDS != null) ? tNANOSECONDS : (tNANOSECONDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NANOSECONDS"));
	} 

	//Time_Of_Day:
	//	value=Time_Of_Day_Value;
	public Time_Of_DayElements getTime_Of_DayAccess() {
		return (pTime_Of_Day != null) ? pTime_Of_Day : (pTime_Of_Day = new Time_Of_DayElements());
	}
	
	public ParserRule getTime_Of_DayRule() {
		return getTime_Of_DayAccess().getRule();
	}

	//Time_Of_Day_Value:
	//	(Tod_Type_Name | "LTIME_OF_DAY") "#" DAYTIME_VALUE;
	public Time_Of_Day_ValueElements getTime_Of_Day_ValueAccess() {
		return (pTime_Of_Day_Value != null) ? pTime_Of_Day_Value : (pTime_Of_Day_Value = new Time_Of_Day_ValueElements());
	}
	
	public ParserRule getTime_Of_Day_ValueRule() {
		return getTime_Of_Day_ValueAccess().getRule();
	}

	//Daytime:
	//	value=DAYTIME_VALUE;
	public DaytimeElements getDaytimeAccess() {
		return (pDaytime != null) ? pDaytime : (pDaytime = new DaytimeElements());
	}
	
	public ParserRule getDaytimeRule() {
		return getDaytimeAccess().getRule();
	}

	//terminal DAYTIME_VALUE:
	//	DEC_VALUE ":" DEC_VALUE ":" FIX_POINT;
	public TerminalRule getDAYTIME_VALUERule() {
		return (tDAYTIME_VALUE != null) ? tDAYTIME_VALUE : (tDAYTIME_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAYTIME_VALUE"));
	} 

	//Date:
	//	value=DATE_VALUE;
	public DateElements getDateAccess() {
		return (pDate != null) ? pDate : (pDate = new DateElements());
	}
	
	public ParserRule getDateRule() {
		return getDateAccess().getRule();
	}

	//terminal DATE_VALUE:
	//	("DATE" | "LDATE" | "D" | "LD") "#" DATE_LITERAL;
	public TerminalRule getDATE_VALUERule() {
		return (tDATE_VALUE != null) ? tDATE_VALUE : (tDATE_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DATE_VALUE"));
	} 

	//terminal DATE_LITERAL:
	//	DEC_VALUE "-" DEC_VALUE "-" DEC_VALUE;
	public TerminalRule getDATE_LITERALRule() {
		return (tDATE_LITERAL != null) ? tDATE_LITERAL : (tDATE_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DATE_LITERAL"));
	} 

	//Date_And_Time:
	//	value=Date_And_Time_Value;
	public Date_And_TimeElements getDate_And_TimeAccess() {
		return (pDate_And_Time != null) ? pDate_And_Time : (pDate_And_Time = new Date_And_TimeElements());
	}
	
	public ParserRule getDate_And_TimeRule() {
		return getDate_And_TimeAccess().getRule();
	}

	////// Table 10 - Elementary data types
	////Data_Type_Access : Elem_Type_Name | Derived_Type_Access;
	////Elem_Type_Name : Numeric_Type_Name | 
	////	Bit_Str_Type_Name | 
	////	String_Type_Name | 
	////	Date_Type_Name | 
	////	Time_Type_Name
	////;
	////Numeric_Type_Name : Int_Type_Name | 
	////	Real_Type_Name
	////;
	////Int_Type_Name : Sign_Int_Type_Name | 
	////	Unsign_Int_Type_Name
	////;
	////Sign_Int_Type_Name : 'SINT' | 
	////	'INT' | 
	////	'DINT' | 
	////	'LINT';
	////Unsign_Int_Type_Name : 'USINT' | 
	////	'UINT' | 
	////	'UDINT' | 
	////	'ULINT';
	////Real_Type_Name : 'LREAL' | 
	////	'REAL';
	////SString_Type_Name : 'STRING' ( '[' Unsigned_Int ']' )?;
	////WString_Type_Name : 'WSTRING' ( '[' Unsigned_Int ']' )?;
	////String_Type_Name : SString_Type_Name | 
	////	WString_Type_Name | 
	////	'CHAR' | 
	////	'WCHAR';
	////Bit_Str_Type_Name : Bool_Type_Name | 
	////	Multibits_Type_Name
	////;
	////Bool_Type_Name : 'BOOL';
	////Multibits_Type_Name : 'BYTE' | 
	////	'WORD' | 
	////	'DWORD' | 
	////	'LWORD';
	////
	////
	////// Table 11 - Declaration of user-defined data types and initialization
	////Derived_Type_Access : Qualified_Name | 
	////	String_Type_Access
	////;
	////String_Type_Access : Qualified_Prefix String_Type_Name;
	////Qualified_Prefix : ( IDENTIFIER Dot )+ ;
	////Qualified_Name : (Qualified_Prefix IDENTIFIER) | IDENTIFIER;
	////This_Qualified_Name : 'THIS' Dot Qualified_Name;
	////Data_Type_Decl : 'TYPE' ( typeDeclarations+=Type_Decl ';' )+ 'END_TYPE';
	////Struct_Decl :'STRUCT' (overlap?='OVERLAP')? ( elements+=Struct_Elem_Decl ';' )+ 'END_STRUCT';
	////Type_Decl : Simple_Type_Decl | Subrange_Type_Decl | Enum_Type_Decl | Array_Type_Decl | Struct_Type_Decl | Str_Type_Decl | Ref_Type_Decl;
	////Simple_Type_Decl : type=IDENTIFIER ':' initialization=Simple_Spec_Init;
	////Subrange_Type_Decl : type=IDENTIFIER ':' initialization=Subrange_Spec_Init;
	////Enum_Type_Decl : type=IDENTIFIER ':' initialization=( Elem_Named_Spec | Enum_Spec_Init );
	////Array_Type_Decl : type=IDENTIFIER ':' initialization=Array_Spec_Init;
	////Struct_Type_Decl : type=IDENTIFIER ':' initialization=Struct_Spec;
	////Struct_Elem_Decl : type=IDENTIFIER ( location=Located_At access=Multibit_Part_Access ? )? ':' initialization=( Simple_Spec_Init | Subrange_Spec_Init | Enum_Spec_Init | Array_Spec_Init | Struct_Spec_Init );
	////Str_Type_Decl : type=String_Type_Name ':' initialization=String_Type_Name ( ASSIGNMENT initialValue=Char_Str )?;
	////
	////Simple_Spec : type=(Elem_Type_Name | Qualified_Name);
	////Subrange_Spec : (type=Int_Type_Name '(' range=Subrange ')') | (refRange=Qualified_Name);
	////Enum_Value_Spec : type=IDENTIFIER ( ASSIGNMENT ( initialValue=Int_Literal | initialization=Constant_Expr ) )?;
	////Elem_Named_Spec : type=Elem_Type_Name ? initialization=Named_Spec_Init;
	////Array_Spec : type=(Qualified_Name | 'ARRAY') '[' ranges+=Subrange ( ',' ranges+=Subrange )* ']' 'OF' refDataType=Data_Type_Access;
	////Struct_Spec : Struct_Decl | Struct_Spec_Init;
	////Simple_Spec_Init : type=Simple_Spec ( ASSIGNMENT initialValue=Constant_Expr )?;
	////Subrange_Spec_Init : type=Subrange_Spec ( ASSIGNMENT initialValue=Signed_Int )?;
	////Subrange : lowBound=Constant_Expr '..' upBound=Constant_Expr;
	////Named_Spec_Init : '(' initialValues+=Enum_Value_Spec ( ',' initialValues+=Enum_Value_Spec )* ')' ( ASSIGNMENT value=Enum_Value )?;
	////
	////Enum_Spec_Init : type=( Enum_Item | Enum_Items | Qualified_Name ) ( ASSIGNMENT value=Enum_Value)?;
	////Enum_Item : '(' IDENTIFIER ')';
	////Enum_Items : '(' IDENTIFIER ( ','  IDENTIFIER )+ ')' ;
	////Enum_Value : value=(Enum_Qualified_Id | IDENTIFIER);
	////Enum_Qualified_Id : Qualified_Name '#' IDENTIFIER;
	////Array_Spec_Init : type=Array_Spec ( ASSIGNMENT initialValue=Array_Init )?;
	////Array_Init : '[' initialValues+=Array_Elem_Init ( ',' initialValues+=Array_Elem_Init )* ']';
	////Array_Elem_Init : (initialization=Array_Elem_Init_Value | initialValue=Unsigned_Int) '(' bound=Array_Elem_Init_Value ? ')';
	////Array_Elem_Init_Value : Constant_Expr | Enum_Value | Struct_Init | Array_Init;
	////
	////Struct_Spec_Init : type=Qualified_Name ( ASSIGNMENT initialValue=Struct_Init )?;
	////Struct_Init : '(' elementInits+=Struct_Elem_Init ( ',' elementInits+=Struct_Elem_Init )* ')';
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: uncomment Constant_Expr below ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Struct_Elem_Init : type=IDENTIFIER ASSIGNMENT initialization=( / * Constant_Expr | * / Enum_Value | Array_Init | Ref_Value | Struct_Init );
	////
	////
	////// Table 16 - Directly represented variables
	////Direct_Variable : '%' locationPrefix=( 'I' | 'Q' | 'M' ) sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' )? bitIndexes+=Unsigned_Int ( Dot bitIndexes+=Unsigned_Int )*;
	////
	////
	////// Table 12 - Reference operations
	////Ref_Type_Decl : type=IDENTIFIER ':' initialization=Ref_Spec_Init;
	////Ref_Spec_Init : type=Ref_Spec ( ASSIGNMENT initialValue=Ref_Value )?;
	////Ref_Spec : 'REF_TO' + reference=Data_Type_Access;
	////Ref_Value : {Ref_Value} (reference=Ref_Addr | 'NULL');
	////Ref_Addr : 'REF' '(' ( referencedVar=Symbolic_Variable | referencedName=(FB_Instance_Name | Class_Instance_Name ) ) ')';
	////Ref_Assign : type=IDENTIFIER ASSIGNMENT ( initialValue=IDENTIFIER | initialization=(Ref_Deref | Ref_Value) );
	////Ref_Deref : name= IDENTIFIER '^'+;
	////
	////
	////// Table 13 - Declaration of variables/Table 14 – Initialization of variables
	////Variable : Direct_Variable | Symbolic_Variable;
	////Symbolic_Variable : name=This_Qualified_Name variable=( Var_Access | Multi_Elem_Var );
	////Var_Access : {Var_Access} (variable=IDENTIFIER | reference=Ref_Deref);
	////Multi_Elem_Var : access=Var_Access elements+=( Subscript_List | Struct_Variable )+;
	////Subscript_List : '[' item+=Subscript ( ',' item+=Subscript )* ']';
	////Subscript : Expression;
	////Struct_Variable : Dot Struct_Elem_Select;
	////Struct_Elem_Select : Var_Access;
	////Input_Decls : {Input_Decls} 'VAR_INPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( inputs+=Input_Decl ';' )* 'END_VAR';
	////Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
	////Edge_Decl : variables=Variable_List ':' Bool_Type_Name edgeType=( 'R_EDGE' | 'F_EDGE' );
	////Var_Decl_Init : variables=Variable_List ':' initialization=(( Simple_Spec_Init | Str_Var_Decl | Ref_Spec_Init ) | Array_Var_Decl_Init | Struct_Var_Decl_Init | FB_Decl_Init | Interface_Spec_Init);
	////Ref_Var_Decl : variables=Variable_List ':' initialization=Ref_Spec;
	////Interface_Var_Decl : variables=Variable_List ':' initialization=Qualified_Name;
	////Variable_List : variables+=IDENTIFIER ( ',' variables+=IDENTIFIER )*;
	////Array_Var_Decl_Init : variables=Variable_List ':' initialization=Array_Spec_Init;
	////Array_Conformand : 'ARRAY' '[' '*' ( ',' '*' )* ']' 'OF' dataType=Data_Type_Access;
	////Array_Conform_Decl : variables=Variable_List ':' conformand=Array_Conformand;
	////Struct_Var_Decl_Init : variables=Variable_List ':' initialization=Struct_Spec_Init;
	////FB_Decl_No_Init : (names+=IDENTIFIER ( ',' names+=IDENTIFIER )*) ':' type=FB_Type_Access;
	////FB_Decl_Init : fb=FB_Decl_No_Init ( ASSIGNMENT initialization=Struct_Init )?;
	////FB_Instance_Name : Qualified_Name '^'*;
	////Output_Decls : {Output_Decls} 'VAR_OUTPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( outputs+=Output_Decl ';' )* 
	////	'END_VAR';
	////Output_Decl : Var_Decl_Init | Array_Conform_Decl;
	////In_Out_Decls : {In_Out_Decls} 'VAR_IN_OUT' ( inouts+=In_Out_Var_Decl ';' )* 
	////	'END_VAR';
	////In_Out_Var_Decl : Var_Decl | Array_Conform_Decl | FB_Decl_No_Init;
	////Var_Decl : variables=Variable_List ':' initialization=( Simple_Spec | Str_Var_Decl | Array_Var_Decl | Struct_Var_Decl );
	////Array_Var_Decl : variables=Variable_List ':' initialization=Array_Spec;
	////Struct_Var_Decl : variables=Variable_List ':' initialization=Qualified_Name;
	////Var_Decls : {Var_Decls} 'VAR' (constant?='CONSTANT' ?) access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
	////Retain_Var_Decls : {Retain_Var_Decls} 'VAR' 'RETAIN' access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
	////Loc_Var_Decls : {Loc_Var_Decls} 'VAR' modifier=( 'CONSTANT' | 'RETAIN' | 'NON_RETAIN' )? ( variables+=Loc_Var_Decl ';' )* 'END_VAR';
	////Loc_Var_Decl : name=IDENTIFIER ? location=Located_At ':' initialization=Loc_Var_Spec_Init;
	////Temp_Var_Decls : {Temp_Var_Decls} 'VAR_TEMP' ( variables+=( Var_Decl | Ref_Var_Decl | Interface_Var_Decl ) ';' )* 'END_VAR';
	////External_Var_Decls : {External_Var_Decls} 'VAR_EXTERNAL' (constant?='Constant' ?) ( variables+=External_Decl ';' )* 'END_VAR';
	////External_Decl : name=IDENTIFIER ':' ( initialization=(Simple_Spec | Array_Spec) | type=(Qualified_Name | FB_Type_Access | Qualified_Name ));
	////Global_Var_Decls : {Global_Var_Decls} 'VAR_GLOBAL' modifier=( 'CONSTANT' | 'RETAIN' )? ( variables+=Global_Var_Decl ';' )* 'END_VAR';
	////Global_Var_Decl : name=Global_Var_Spec ':' ( initialization=Loc_Var_Spec_Init | type=FB_Type_Access );
	////Global_Var_Spec : ( variables+=IDENTIFIER ( ',' variables+=IDENTIFIER )* ) | ( variables+=IDENTIFIER location=Located_At );
	////Loc_Var_Spec_Init : Simple_Spec_Init | Array_Spec_Init | Struct_Spec_Init | S_Byte_Str_Spec | D_Byte_Str_Spec;
	////Located_At : 'AT' Direct_Variable;
	////Str_Var_Decl : S_Byte_Str_Var_Decl | D_Byte_Str_Var_Decl;
	////S_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=S_Byte_Str_Spec;
	////S_Byte_Str_Spec : {S_Byte_Str_Spec} 'STRING' ( '[' bound=Unsigned_Int ']' )? ( ASSIGNMENT initialValue=S_Byte_Char_Str )?;
	////D_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=D_Byte_Str_Spec;
	////D_Byte_Str_Spec : {D_Byte_Str_Spec} 'WSTRING' ( '[' bound=Unsigned_Int ']' )? ( ASSIGNMENT initialValue=D_Byte_Char_Str )?;
	////Loc_Partly_Var_Decl : {Loc_Partly_Var_Decl} 'VAR' modifier=( 'RETAIN' | 'NON_RETAIN' )? variables+=Loc_Partly_Var * 'END_VAR';
	////Loc_Partly_Var : name=IDENTIFIER 'AT' '%' locationPrefix=( 'I' | 'Q' | 'M' ) '*' ':' initialization=Var_Spec ';';
	////Var_Spec : Simple_Spec | Array_Spec | Qualified_Name | StringVar_Spec;
	////StringVar_Spec: type=( 'STRING' | 'WSTRING' ) ( '[' bound=Unsigned_Int ']' )?;
	////
	////// Table 19 - Function declaration
	////Func_Name : Std_Func_Name | IDENTIFIER;
	////Std_Func_Name : 'TRUNC' | 'ABS' | 'SQRT' | 'LN' | 'LOG' | 'EXP' | 
	////	'SIN' | 'COS' | 'TAN' | 'ASIN' | 'ACOS' | 'ATAN' | 'ATAN2 ' | 
	////	'ADD' | 'SUB' | 'MUL' | 'DIV' | 'MOD' | 'EXPT' | 'MOVE ' | 
	////	'SHL' | 'SHR' | 'ROL' | 'ROR' | 'AND' | 'OR'  | 'XOR' | 'NOT' | 
	////	'SEL' | 'MAX' | 'MIN' | 'LIMIT' | 'MUX ' | 'GT' | 'GE' | 'EQ' | 
	////	'LE' | 'LT' | 'NE' | 'LEN' | 'LEFT' | 'RIGHT' | 'MID' | 'CONCAT' | 
	////	'INSERT' | 'DELETE' | 'REPLACE' | 'FIND';
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: complete list above ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Func_Decl : 'FUNCTION' name=IDENTIFIER ( ':' returnType=Data_Type_Access )? usings+=Using_Directive* ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
	////		'END_FUNCTION';
	////IO_Var_Decls : Input_Decls | Output_Decls | In_Out_Decls;
	////Func_Var_Decls : External_Var_Decls | Var_Decls;
	////
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: other languages on list below ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Func_Body : / *Ladder_Diagram | FB_Diagram | Instruction_List |* / Stmt_List;// | Other_Languages;
	////
	////
	////// Table 40 – Function block type declaration
	////
	////// Table 41 - Function block instance declaration
	////FB_Type_Name : Std_FB_Name | IDENTIFIER;
	////FB_Type_Access : Qualified_Prefix FB_Type_Name | FB_Type_Name;
	////Std_FB_Name : 'SR' | 'RS' | 'R_TRIG' | 'F_TRIG' | 'CTU'| 'CTD' | 'CTUD' | 'TP' | 'TON' | 'TOF';
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: complete list above ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////FB_Decl : 'FUNCTION_BLOCK' modifier=( 'FINAL' | 'ABSTRACT' )? name=IDENTIFIER usings+=Using_Directive* ( 'EXTENDS' extends=( FB_Type_Access | Qualified_Name ) )?
	////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( ios+=FB_IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls )*
	////	( methods+=Method_Decl )* body=FB_Body ? 
	////	'END_FUNCTION_BLOCK';
	////FB_IO_Var_Decls : FB_Input_Decls | FB_Output_Decls | In_Out_Decls;
	////FB_Input_Decls : {FB_Input_Decls} 'VAR_INPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Input_Decl ';' )* 'END_VAR';
	////FB_Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
	////FB_Output_Decls : {FB_Output_Decls} 'VAR_OUTPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Output_Decl ';' )* 'END_VAR';
	////FB_Output_Decl : Var_Decl_Init | Array_Conform_Decl;
	////Other_Var_Decls : Retain_Var_Decls | No_Retain_Var_Decls | Loc_Partly_Var_Decl;
	////No_Retain_Var_Decls : {No_Retain_Var_Decls} 'VAR' 'NON_RETAIN' access=Access_Spec ? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
	////
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: other languages on list below ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////FB_Body : Stmt_List; //| SFC | Ladder_Diagram | FB_Diagram | Instruction_List | Other_Languages;
	////Method_Decl : 'METHOD' access=Access_Spec type=( 'FINAL' | 'ABSTRACT' )? override?='OVERRIDE'?
	////	name=IDENTIFIER ( ':' returnType=Data_Type_Access )? ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
	////	'END_METHOD';
	////
	////// Table 48 - Class
	////
	////// Table 50 Textual call of methods – Formal and non-formal parameter list
	////Class_Decl : 'CLASS' modifier=( 'FINAL' | 'ABSTRACT' )? name=IDENTIFIER usings+=Using_Directive* ( 'EXTENDS' extends=Qualified_Name )? 
	////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( variables+=Func_Var_Decls | others+=Other_Var_Decls )* ( methods+=Method_Decl )* 
	////	'END_CLASS';
	////Class_Instance_Name : Qualified_Name '^' *;
	////Interface_Decl : 'INTERFACE' name=IDENTIFIER usings+=Using_Directive* 
	////	( 'EXTENDS' extends+=Interface_Name_List )? 
	////	methods+=Method_Prototype* 
	////	'END_INTERFACE';
	////Method_Prototype : 'METHOD' name=IDENTIFIER ( ':' returnType=Data_Type_Access )? ios+=IO_Var_Decls* 
	////	'END_METHOD';
	////Interface_Spec_Init : variables=Variable_List ( ASSIGNMENT initialization=Interface_Value )?;
	////Interface_Value : ((variable=Symbolic_Variable) | variableName=(FB_Instance_Name | Class_Instance_Name | 'NULL'));
	////Interface_Name_List : interfaces+=Qualified_Name ( ',' interfaces+=Qualified_Name )*;
	////Access_Spec : 'PUBLIC' | 'PROTECTED' | 'PRIVATE' | 'INTERNAL';
	////
	////// Table 47 - Program declaration
	////Prog_Decl : 'PROGRAM' name=IDENTIFIER
	////	( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls | locals+=Loc_Var_Decls | acesses+=Prog_Access_Decls )* 
	////body=FB_Body 'END_PROGRAM';
	////Prog_Access_Decls : {Prog_Access_Decls} 'VAR_ACCESS' ( accesses+=Prog_Access_Decl ';' )* 'END_VAR';
	////Prog_Access_Decl : name=IDENTIFIER ':' variable=Symbolic_Variable access=Multibit_Part_Access? ':' dataType=Data_Type_Access direction=Access_Direction?;
	////
	////// Table 62 - Configuration and resource declaration
	//////Config_Decl : 'CONFIGURATION' Config_Name Global_Var_Decls ?
	//////( Single_Resource_Decl | Resource_Decl + ) Access_Decls ? Config_Init ?
	//////'END_CONFIGURATION';
	//////Resource_Decl : 'RESOURCE' Resource_Name 'ON' Resource_Type_Name
	//////Global_Var_Decls ? Single_Resource_Decl
	//////'END_RESOURCE';
	//////Single_Resource_Decl : ( Task_Config ';' )* ( Prog_Config ';' )+;
	//////Access_Decls : 'VAR_ACCESS' ( Access_Decl ';' )* 'END_VAR';
	//////Access_Decl : IDENTIFIER ':' Access_Path ':' Data_Type_Access Access_Direction ?;
	//////Access_Path : ( Resource_Name Dot )? Direct_Variable
	//////| ( Resource_Name Dot )? ( Prog_Name Dot )?
	//////( ( FB_Instance_Name | Class_Instance_Name ) Dot )* Symbolic_Variable;
	//////Global_Var_Access : ( Resource_Name Dot )? IDENTIFIER ( Dot Struct_Elem_Name )?;
	//////Prog_Output_Access : Prog_Name Dot Symbolic_Variable;
	////Access_Direction : 'READ_WRITE' | 'READ_ONLY';
	//////Task_Config : 'TASK' Task_Name Task_Init;
	//////Task_Init : '(' ( 'SINGLE' ASSIGNMENT Data_Source ',' )?
	//////( 'INTERVAL' ASSIGNMENT Data_Source ',' )?
	//////'PRIORITY' ASSIGNMENT Unsigned_Int ')';
	//////Data_Source : Constant | Global_Var_Access | Prog_Output_Access | Direct_Variable;
	//////Prog_Config : 'PROGRAM' ( 'RETAIN' | 'NON_RETAIN' )? Prog_Name ( 'WITH' Task_Name )? ':'
	//////Prog_Type_Access ( '(' Prog_Conf_Elems ')' )?;
	//////Prog_Conf_Elems : Prog_Conf_Elem ( ',' Prog_Conf_Elem )*;
	//////Prog_Conf_Elem : FB_Task | Prog_Cnxn;
	//////FB_Task : FB_Instance_Name 'WITH' Task_Name;
	//////Prog_Cnxn : Symbolic_Variable ASSIGNMENT Prog_Data_Source | Symbolic_Variable '=>' Data_Sink;
	//////Prog_Data_Source : Constant | Enum_Value | Global_Var_Access | Direct_Variable;
	//////Data_Sink : Global_Var_Access | Direct_Variable;
	//////Config_Init : 'VAR_CONFIG' ( Config_Inst_Init ';' )* 'END_VAR';
	//////Config_Inst_Init : Resource_Name Dot Prog_Name Dot ( ( FB_Instance_Name | Class_Instance_Name ) Dot )*
	//////( IDENTIFIER Located_At ? ':' Loc_Var_Spec_Init
	//////| ( ( FB_Instance_Name ':' FB_Type_Access )
	//////| ( Class_Instance_Name ':' Qualified_Name ) ) ASSIGNMENT Struct_Init );
	//////
	//////// Table 64 - Namespace
	//////Namespace_Decl : 'NAMESPACE' 'INTERNAL' ? Namespace_H_Name Using_Directive * Namespace_Elements
	//////'END_NAMESPACE';
	//////Namespace_Elements : ( Data_Type_Decl | Func_Decl | FB_Decl
	//////| Class_Decl | Interface_Decl | Namespace_Decl )+;
	////Using_Directive : 'USING' namespaces+=Qualified_Name ( ',' namespaces+=Qualified_Name )* ';';
	//////POU_Decl : Using_Directive *
	//////( Global_Var_Decls | Data_Type_Decl | Access_Decls
	//////| Func_Decl | FB_Decl | Class_Decl | Interface_Decl
	//////| Namespace_Decl )+;
	//////
	////
	////// Table 71 - 72 - Language Structured Text (ST)
	////Expression returns Expression: Xor_Expr ({Expression.left=current} operator='OR' right=Xor_Expr )*;
	////// a constant expression must evaluate to a constant value at compile time
	////Constant_Expr : Expression;
	////Xor_Expr returns Expression: And_Expr ({Xor_Expr.left=current} operator='XOR' right=And_Expr )*;
	////And_Expr returns Expression: Compare_Expr ({And_Expr.left=current} operator=( '&' | 'AND' ) right=Compare_Expr )*;
	////Compare_Expr returns Expression: Equ_Expr ({Compare_Expr.left=current} operator=( '=' | '<>' ) right=Equ_Expr )*;
	////Equ_Expr returns Expression: Add_Expr ({Equ_Expr.left=current} operator=( '<' | '>' | '<=' | '>=' ) right=Add_Expr )*;
	////Add_Expr returns Expression: Term ({Add_Expr.left=current} operator=Number_Sign right=Term )*;
	////Term returns Expression: Power_Expr ({Term.left=current} operator=('*' | '/' | 'MOD') right=Power_Expr )*;
	////Power_Expr returns Expression: Unary_Expr ({Power_Expr.left=current} operator='**' right=Unary_Expr )*;
	////Unary_Expr returns Expression: operator=('-' | '+' | 'NOT')? expression=Primary_Expr;
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below Func_Call |  Ref_Value | '(' Expression ')'^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Primary_Expr returns Expression: {Expression} Constant | Enum_Value | Variable_Access / * | Func_Call |  Ref_Value | '(' Expression ')' * /;
	////
	////Variable_Access : variable=Variable access=Multibit_Part_Access ?;
	////Multibit_Part_Access : Dot ( accessSize=Unsigned_Int | accessSizeInfo=Size_Info );
	////Size_Info : '%' sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' ) ? size=Unsigned_Int;
	////Func_Call : access=Qualified_Name '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
	////Stmt_List : {Stmt_List} ( statement+=Stmt ? ';' )*;
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below Assign_Stmt | Subprog_Ctrl_Stmt |^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Stmt : / * Assign_Stmt | Subprog_Ctrl_Stmt | * / Selection_Stmt | Iteration_Stmt;
	////Assign_Stmt : Variable_Assign_Stmt | Ref_Assign | Assignment_Attempt;
	////Variable_Assign_Stmt : left=Variable ASSIGNMENT right=Expression;
	////Assignment_Attempt : ( leftName=IDENTIFIER | leftReference=Ref_Deref ) '?=' ( rightName=IDENTIFIER | rightReference=(Ref_Deref | Ref_Value) );
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below | Qualified_Method_Call^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Invocation : method=( FB_Instance_Name | IDENTIFIER | 'THIS' / * | Qualified_Method_Call * / ) '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
	////// Qualified_Method_Call : ( ( 'THIS' Dot )? ( ( ( FB_Instance_Name | Class_Instance_Name ) Dot )+ ) IDENTIFIER );
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Subprog_Ctrl_Stmt : / * Func_Call | Invocation | * / Super_Invocation | Return;
	////Sub_Invocation: Super_Invocation | Return;
	////Super_Invocation : 'SUPER' '(' ')';
	////Return : 'RETURN';
	////Param_Assign : Named_Value | Ref_Assign | Linked_Value;
	////Named_Value : ( name=IDENTIFIER ASSIGNMENT )? value=Expression;
	////Linked_Value : (negated?='NOT')? name=IDENTIFIER '=>' value=Variable;
	////Selection_Stmt : IF_Stmt | Case_Stmt;
	////IF_Stmt : 'IF' condition=Expression 'THEN' statements=Stmt_List ( elseifs+=ELSEIF_Stmt )* ( else=ELSE_Stmt )? 'END_IF';
	////ELSEIF_Stmt : 'ELSIF' condition=Expression 'THEN' statements=Stmt_List;
	////ELSE_Stmt: 'ELSE' statements=Stmt_List;
	////Case_Stmt : 'CASE' expression=Expression 'OF' cases+=Case_Selection + ( 'ELSE' defaultStatements=Stmt_List )? 'END_CASE';
	////Case_Selection : values=Case_List ':' statements=Stmt_List;
	////Case_List : caseValues+=Case_List_Elem ( ',' caseValues+=Case_List_Elem )*;
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Case_List_Elem : Subrange / *| Constant_Expr* /;
	////Iteration_Stmt : For_Stmt | While_Stmt | Repeat_Stmt | Exit_Stmt | Continue_Stmt;
	////Exit_Stmt : {Exit_Stmt} 'EXIT';
	////Continue_Stmt : {Continue_Stmt} 'CONTINUE';
	////For_Stmt : 'FOR' variable=IDENTIFIER ASSIGNMENT bounds=For_List 'DO' statements=Stmt_List 'END_FOR';
	////For_List : lowBound=Expression 'TO' upBound=Expression ( 'BY' step=Expression )?;
	////While_Stmt : 'WHILE' condition=Expression 'DO' statements=Stmt_List 'END_WHILE';
	////Repeat_Stmt : 'REPEAT' statements=Stmt_List 'UNTIL' condition=Expression 'END_REPEAT'; Date_And_Time_Value:
	//	("DATE_AND_TIME" | "LDATE_AND_TIME" | "DT" | "LDT") "#" DATE_LITERAL "-" DAYTIME_VALUE;
	public Date_And_Time_ValueElements getDate_And_Time_ValueAccess() {
		return (pDate_And_Time_Value != null) ? pDate_And_Time_Value : (pDate_And_Time_Value = new Date_And_Time_ValueElements());
	}
	
	public ParserRule getDate_And_Time_ValueRule() {
		return getDate_And_Time_ValueAccess().getRule();
	}
}
