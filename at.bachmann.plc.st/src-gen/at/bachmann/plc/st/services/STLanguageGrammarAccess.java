/*
* generated by Xtext
*/
package at.bachmann.plc.st.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class STLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class TestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "test");
		private final Assignment cTestAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cTestSKeyword_0 = (Keyword)cTestAssignment.eContents().get(0);
		
		//test:
		//	test="s";
		public ParserRule getRule() { return rule; }

		//test="s"
		public Assignment getTestAssignment() { return cTestAssignment; }

		//"s"
		public Keyword getTestSKeyword_0() { return cTestSKeyword_0; }
	}

	public class CONSTANTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CONSTANT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNUMERIC_LITERALTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCHAR_LITERALTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTIME_LITERALParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBIT_STR_LITERALTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cBOOL_LITERALTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// Table 5 - Numeric literal
		//CONSTANT:
		//	NUMERIC_LITERAL | CHAR_LITERAL | TIME_LITERAL | BIT_STR_LITERAL | BOOL_LITERAL;
		public ParserRule getRule() { return rule; }

		//NUMERIC_LITERAL | CHAR_LITERAL | TIME_LITERAL | BIT_STR_LITERAL | BOOL_LITERAL
		public Alternatives getAlternatives() { return cAlternatives; }

		//NUMERIC_LITERAL
		public RuleCall getNUMERIC_LITERALTerminalRuleCall_0() { return cNUMERIC_LITERALTerminalRuleCall_0; }

		//CHAR_LITERAL
		public RuleCall getCHAR_LITERALTerminalRuleCall_1() { return cCHAR_LITERALTerminalRuleCall_1; }

		//TIME_LITERAL
		public RuleCall getTIME_LITERALParserRuleCall_2() { return cTIME_LITERALParserRuleCall_2; }

		//BIT_STR_LITERAL
		public RuleCall getBIT_STR_LITERALTerminalRuleCall_3() { return cBIT_STR_LITERALTerminalRuleCall_3; }

		//BOOL_LITERAL
		public RuleCall getBOOL_LITERALTerminalRuleCall_4() { return cBOOL_LITERALTerminalRuleCall_4; }
	}

	public class TIME_LITERALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TIME_LITERAL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDURATIONParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTIME_OF_DAYTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDATETerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDATE_AND_TIMETerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// Table 8 - DURATION literals
		//// Table 9 – DATE and time of day literals
		//TIME_LITERAL:
		//	DURATION | TIME_OF_DAY | DATE | DATE_AND_TIME;
		public ParserRule getRule() { return rule; }

		//DURATION | TIME_OF_DAY | DATE | DATE_AND_TIME
		public Alternatives getAlternatives() { return cAlternatives; }

		//DURATION
		public RuleCall getDURATIONParserRuleCall_0() { return cDURATIONParserRuleCall_0; }

		//TIME_OF_DAY
		public RuleCall getTIME_OF_DAYTerminalRuleCall_1() { return cTIME_OF_DAYTerminalRuleCall_1; }

		//DATE
		public RuleCall getDATETerminalRuleCall_2() { return cDATETerminalRuleCall_2; }

		//DATE_AND_TIME
		public RuleCall getDATE_AND_TIMETerminalRuleCall_3() { return cDATE_AND_TIMETerminalRuleCall_3; }
	}

	public class DURATIONElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DURATION");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cTIME_TYPE_NAMETerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final Keyword cTKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cLTKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final Keyword cNumberSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cPlusSignKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final RuleCall cINTERVALParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//DURATION:
		//	(TIME_TYPE_NAME | "T" | "LT") "#" ("+" | "-")? INTERVAL;
		public ParserRule getRule() { return rule; }

		//(TIME_TYPE_NAME | "T" | "LT") "#" ("+" | "-")? INTERVAL
		public Group getGroup() { return cGroup; }

		//TIME_TYPE_NAME | "T" | "LT"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//TIME_TYPE_NAME
		public RuleCall getTIME_TYPE_NAMETerminalRuleCall_0_0() { return cTIME_TYPE_NAMETerminalRuleCall_0_0; }

		//"T"
		public Keyword getTKeyword_0_1() { return cTKeyword_0_1; }

		//"LT"
		public Keyword getLTKeyword_0_2() { return cLTKeyword_0_2; }

		//"#"
		public Keyword getNumberSignKeyword_1() { return cNumberSignKeyword_1; }

		//("+" | "-")?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"+"
		public Keyword getPlusSignKeyword_2_0() { return cPlusSignKeyword_2_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_2_1() { return cHyphenMinusKeyword_2_1; }

		//INTERVAL
		public RuleCall getINTERVALParserRuleCall_3() { return cINTERVALParserRuleCall_3; }
	}

	public class INTERVALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "INTERVAL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDAYSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cHOURSTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMINUTESTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSECONDSTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cMILLISECONDSTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cMICROSECONDSTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNANOSECONDSTerminalRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//INTERVAL:
		//	DAYS | HOURS | MINUTES | SECONDS | MILLISECONDS | MICROSECONDS | NANOSECONDS;
		public ParserRule getRule() { return rule; }

		//DAYS | HOURS | MINUTES | SECONDS | MILLISECONDS | MICROSECONDS | NANOSECONDS
		public Alternatives getAlternatives() { return cAlternatives; }

		//DAYS
		public RuleCall getDAYSTerminalRuleCall_0() { return cDAYSTerminalRuleCall_0; }

		//HOURS
		public RuleCall getHOURSTerminalRuleCall_1() { return cHOURSTerminalRuleCall_1; }

		//MINUTES
		public RuleCall getMINUTESTerminalRuleCall_2() { return cMINUTESTerminalRuleCall_2; }

		//SECONDS
		public RuleCall getSECONDSTerminalRuleCall_3() { return cSECONDSTerminalRuleCall_3; }

		//MILLISECONDS
		public RuleCall getMILLISECONDSTerminalRuleCall_4() { return cMILLISECONDSTerminalRuleCall_4; }

		//MICROSECONDS
		public RuleCall getMICROSECONDSTerminalRuleCall_5() { return cMICROSECONDSTerminalRuleCall_5; }

		//NANOSECONDS
		public RuleCall getNANOSECONDSTerminalRuleCall_6() { return cNANOSECONDSTerminalRuleCall_6; }
	}

	public class String_Type_AccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "String_Type_Access");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cNamespace_NameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cSTRING_TYPE_NAMETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//// Table 11 - Declaration of user-defined data types and initialization
		////Derived_Type_Access : Single_Elem_Type_Access | Array_Type_Access | Struct_Type_Access | String_Type_Access | Class_Type_Access | Ref_Type_Access | Interface_Type_Access;
		//String_Type_Access:
		//	(Namespace_Name DOT)* STRING_TYPE_NAME;
		public ParserRule getRule() { return rule; }

		//(Namespace_Name DOT)* STRING_TYPE_NAME
		public Group getGroup() { return cGroup; }

		//(Namespace_Name DOT)*
		public Group getGroup_0() { return cGroup_0; }

		//Namespace_Name
		public RuleCall getNamespace_NameParserRuleCall_0_0() { return cNamespace_NameParserRuleCall_0_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_0_1() { return cDOTTerminalRuleCall_0_1; }

		//STRING_TYPE_NAME
		public RuleCall getSTRING_TYPE_NAMETerminalRuleCall_1() { return cSTRING_TYPE_NAMETerminalRuleCall_1; }
	}

	public class Single_Elem_Type_AccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Single_Elem_Type_Access");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSimple_Type_AccessParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubrange_Type_AccessParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEnum_Type_AccessParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Single_Elem_Type_Access:
		//	Simple_Type_Access | Subrange_Type_Access | Enum_Type_Access;
		public ParserRule getRule() { return rule; }

		//Simple_Type_Access | Subrange_Type_Access | Enum_Type_Access
		public Alternatives getAlternatives() { return cAlternatives; }

		//Simple_Type_Access
		public RuleCall getSimple_Type_AccessParserRuleCall_0() { return cSimple_Type_AccessParserRuleCall_0; }

		//Subrange_Type_Access
		public RuleCall getSubrange_Type_AccessParserRuleCall_1() { return cSubrange_Type_AccessParserRuleCall_1; }

		//Enum_Type_Access
		public RuleCall getEnum_Type_AccessParserRuleCall_2() { return cEnum_Type_AccessParserRuleCall_2; }
	}

	public class Simple_Type_AccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Simple_Type_Access");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cNamespace_NameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cSimple_Type_NameParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Simple_Type_Access:
		//	(Namespace_Name DOT)* Simple_Type_Name;
		public ParserRule getRule() { return rule; }

		//(Namespace_Name DOT)* Simple_Type_Name
		public Group getGroup() { return cGroup; }

		//(Namespace_Name DOT)*
		public Group getGroup_0() { return cGroup_0; }

		//Namespace_Name
		public RuleCall getNamespace_NameParserRuleCall_0_0() { return cNamespace_NameParserRuleCall_0_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_0_1() { return cDOTTerminalRuleCall_0_1; }

		//Simple_Type_Name
		public RuleCall getSimple_Type_NameParserRuleCall_1() { return cSimple_Type_NameParserRuleCall_1; }
	}

	public class Subrange_Type_AccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Subrange_Type_Access");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cNamespace_NameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cSubrange_Type_NameParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Subrange_Type_Access:
		//	(Namespace_Name DOT)* Subrange_Type_Name;
		public ParserRule getRule() { return rule; }

		//(Namespace_Name DOT)* Subrange_Type_Name
		public Group getGroup() { return cGroup; }

		//(Namespace_Name DOT)*
		public Group getGroup_0() { return cGroup_0; }

		//Namespace_Name
		public RuleCall getNamespace_NameParserRuleCall_0_0() { return cNamespace_NameParserRuleCall_0_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_0_1() { return cDOTTerminalRuleCall_0_1; }

		//Subrange_Type_Name
		public RuleCall getSubrange_Type_NameParserRuleCall_1() { return cSubrange_Type_NameParserRuleCall_1; }
	}

	public class Enum_Type_AccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Enum_Type_Access");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cNamespace_NameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cEnum_Type_NameParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Enum_Type_Access:
		//	(Namespace_Name DOT)* Enum_Type_Name;
		public ParserRule getRule() { return rule; }

		//(Namespace_Name DOT)* Enum_Type_Name
		public Group getGroup() { return cGroup; }

		//(Namespace_Name DOT)*
		public Group getGroup_0() { return cGroup_0; }

		//Namespace_Name
		public RuleCall getNamespace_NameParserRuleCall_0_0() { return cNamespace_NameParserRuleCall_0_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_0_1() { return cDOTTerminalRuleCall_0_1; }

		//Enum_Type_Name
		public RuleCall getEnum_Type_NameParserRuleCall_1() { return cEnum_Type_NameParserRuleCall_1; }
	}

	public class Array_Type_AccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Array_Type_Access");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cNamespace_NameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cArray_Type_NameParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Array_Type_Access:
		//	(Namespace_Name DOT)* Array_Type_Name;
		public ParserRule getRule() { return rule; }

		//(Namespace_Name DOT)* Array_Type_Name
		public Group getGroup() { return cGroup; }

		//(Namespace_Name DOT)*
		public Group getGroup_0() { return cGroup_0; }

		//Namespace_Name
		public RuleCall getNamespace_NameParserRuleCall_0_0() { return cNamespace_NameParserRuleCall_0_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_0_1() { return cDOTTerminalRuleCall_0_1; }

		//Array_Type_Name
		public RuleCall getArray_Type_NameParserRuleCall_1() { return cArray_Type_NameParserRuleCall_1; }
	}

	public class Struct_Type_AccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Struct_Type_Access");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cNamespace_NameParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cStruct_Type_NameParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Struct_Type_Access:
		//	(Namespace_Name DOT)* Struct_Type_Name;
		public ParserRule getRule() { return rule; }

		//(Namespace_Name DOT)* Struct_Type_Name
		public Group getGroup() { return cGroup; }

		//(Namespace_Name DOT)*
		public Group getGroup_0() { return cGroup_0; }

		//Namespace_Name
		public RuleCall getNamespace_NameParserRuleCall_0_0() { return cNamespace_NameParserRuleCall_0_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_0_1() { return cDOTTerminalRuleCall_0_1; }

		//Struct_Type_Name
		public RuleCall getStruct_Type_NameParserRuleCall_1() { return cStruct_Type_NameParserRuleCall_1; }
	}

	public class Simple_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Simple_Type_Name");
		private final RuleCall cIDENTIFIERTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Simple_Type_Name returns EString:
		//	IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall() { return cIDENTIFIERTerminalRuleCall; }
	}

	public class Subrange_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Subrange_Type_Name");
		private final RuleCall cIDENTIFIERTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Subrange_Type_Name returns EString:
		//	IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall() { return cIDENTIFIERTerminalRuleCall; }
	}

	public class Enum_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Enum_Type_Name");
		private final RuleCall cIDENTIFIERTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Enum_Type_Name returns EString:
		//	IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall() { return cIDENTIFIERTerminalRuleCall; }
	}

	public class Array_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Array_Type_Name");
		private final RuleCall cIDENTIFIERTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Array_Type_Name returns EString:
		//	IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall() { return cIDENTIFIERTerminalRuleCall; }
	}

	public class Struct_Type_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Struct_Type_Name");
		private final RuleCall cIDENTIFIERTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Struct_Type_Name returns EString:
		//	IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall() { return cIDENTIFIERTerminalRuleCall; }
	}

	public class Namespace_NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Namespace_Name");
		private final RuleCall cIDENTIFIERTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		////
		////Data_Type_Decl : 'TYPE' ( typeDeclarations+=Type_Decl ';' )+ 'END_TYPE';
		////Struct_Decl :'STRUCT' (overlap?='OVERLAP')? ( elements+=Struct_Elem_Decl ';' )+ 'END_STRUCT';
		////
		////Type_Decl : Simple_Type_Decl | Subrange_Type_Decl | Enum_Type_Decl | Array_Type_Decl | Struct_Type_Decl | Str_Type_Decl | Ref_Type_Decl;
		////Simple_Type_Decl : type=Simple_Type_Name ':' initialization=Simple_Spec_Init;
		////Subrange_Type_Decl : type=Subrange_Type_Name ':' initialization=Subrange_Spec_Init;
		////Enum_Type_Decl : type=Enum_Type_Name ':' initialization=( Elem_Named_Spec | Enum_Spec_Init );
		////Array_Type_Decl : type=Array_Type_Name ':' initialization=Array_Spec_Init;
		////Struct_Type_Decl : type=Struct_Type_Name ':' initialization=Struct_Spec;
		////Struct_Elem_Decl : type=Struct_Elem_Name ( location=Located_At access=Multibit_Part_Access ? )? ':' initialization=( Simple_Spec_Init | Subrange_Spec_Init | Enum_Spec_Init | Array_Spec_Init | Struct_Spec_Init );
		////Str_Type_Decl : type=STRING_TYPE_NAME ':' initialization=STRING_TYPE_NAME ( ASSIGNMENT initialValue=CHAR_STR )?;
		////
		////Simple_Spec : type=(ELEM_TYPE_NAME | Simple_Type_Access);
		////Subrange_Spec : (type=INT_TYPE_NAME '(' range=Subrange ')') | (refRange=Subrange_Type_Access);
		////Enum_Value_Spec : type=IDENTIFIER ( ASSIGNMENT ( initialValue=INT_LITERAL | initialization=Constant_Expr ) )?;
		////Elem_Named_Spec : type=ELEM_TYPE_NAME ? initialization=Named_Spec_Init;
		////Array_Spec : type=(Array_Type_Access | 'ARRAY') '[' ranges+=Subrange ( ',' ranges+=Subrange )* ']' 'OF' refDataType=Data_Type_Access;
		////Struct_Spec : Struct_Decl | Struct_Spec_Init;
		////
		////Simple_Spec_Init : type=Simple_Spec ( ASSIGNMENT initialValue=Constant_Expr )?;
		////Subrange_Spec_Init : type=Subrange_Spec ( ASSIGNMENT initialValue=SIGNED_INT )?;
		////Subrange : lowBound=Constant_Expr '..' upBound=Constant_Expr;
		////Named_Spec_Init : '(' initialValues+=Enum_Value_Spec ( ',' initialValues+=Enum_Value_Spec )* ')' ( ASSIGNMENT value=Enum_Value )?;
		////
		////Enum_Spec_Init : ( ( '(' enumItem+=IDENTIFIER ( ',' enumItem+=IDENTIFIER )* ')' ) | refEnum=Enum_Type_Access ) ( ASSIGNMENT value=Enum_Value )?;
		////Enum_Value : ( type=Enum_Type_Name '#' )? value=IDENTIFIER;
		////
		////Array_Spec_Init : type=Array_Spec ( ASSIGNMENT initialValue=Array_Init )?;
		////Array_Init : '[' initialValues+=Array_Elem_Init ( ',' initialValues+=Array_Elem_Init )* ']';
		////Array_Elem_Init : (initialization=Array_Elem_Init_Value | initialValue=UNSIGNED_INT) '(' bound=Array_Elem_Init_Value ? ')';
		////Array_Elem_Init_Value : Constant_Expr | Enum_Value | Struct_Init | Array_Init;
		////
		////Struct_Spec_Init : type=Struct_Type_Access ( ASSIGNMENT initialValue=Struct_Init )?;
		////Struct_Elem_Name returns EString : IDENTIFIER;
		////Struct_Init : '(' elementInits+=Struct_Elem_Init ( ',' elementInits+=Struct_Elem_Init )* ')';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: uncomment Constant_Expr below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Struct_Elem_Init : type=Struct_Elem_Name ASSIGNMENT initialization=( / * Constant_Expr | * / Enum_Value | Array_Init | Ref_Value | Struct_Init );
		////
		////
		////// Table 16 - Directly represented variables
		////Direct_Variable : '%' locationPrefix=( 'I' | 'Q' | 'M' ) sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' )? bitIndexes+=UNSIGNED_INT ( DOT bitIndexes+=UNSIGNED_INT )*;
		////
		////
		////// Table 12 - Reference operations
		////Ref_Type_Decl : type=Ref_Type_Name ':' initialization=Ref_Spec_Init;
		////Ref_Spec_Init : type=Ref_Spec ( ASSIGNMENT initialValue=Ref_Value )?;
		////Ref_Spec : 'REF_TO' + reference=Data_Type_Access;
		////Ref_Type_Name returns EString : IDENTIFIER;
		////Ref_Type_Access : ( Namespace_Name DOT )* Ref_Type_Name;
		////Ref_Name returns EString : IDENTIFIER;
		////Ref_Value : {Ref_Value} (reference=Ref_Addr | 'NULL');
		////Ref_Addr : 'REF' '(' ( referencedVar=Symbolic_Variable | referencedName=(FB_Instance_Name | Class_Instance_Name ) ) ')';
		////Ref_Assign : type=Ref_Name ASSIGNMENT ( initialValue=Ref_Name | initialization=(Ref_Deref | Ref_Value) );
		////Ref_Deref : name=Ref_Name '^' +;
		////
		////
		////// Table 13 - Declaration of variables/Table 14 – Initialization of variables
		////Variable : Direct_Variable | Symbolic_Variable;
		////Symbolic_Variable : (( qualifiers+='THIS' DOT ) | ( qualifiers+=Namespace_Name DOT )+)? variable=( Var_Access | Multi_Elem_Var );
		////Var_Access : {Var_Access} (variable=Variable_Name | reference=Ref_Deref);
		////Variable_Name returns EString : IDENTIFIER;
		////Multi_Elem_Var : access=Var_Access elements+=( Subscript_List | Struct_Variable )+;
		////Subscript_List : '[' item+=Subscript ( ',' item+=Subscript )* ']';
		////Subscript : Expression;
		////Struct_Variable : DOT Struct_Elem_Select;
		////Struct_Elem_Select : Var_Access;
		////Input_Decls : {Input_Decls} 'VAR_INPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( inputs+=Input_Decl ';' )* 'END_VAR';
		////Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
		////Edge_Decl : variables=Variable_List ':' BOOL_TYPE_NAME edgeType=( 'R_EDGE' | 'F_EDGE' );
		////Var_Decl_Init : variables=Variable_List ':' initialization=(( Simple_Spec_Init | Str_Var_Decl | Ref_Spec_Init ) | Array_Var_Decl_Init | Struct_Var_Decl_Init | FB_Decl_Init | Interface_Spec_Init);
		////Ref_Var_Decl : variables=Variable_List ':' initialization=Ref_Spec;
		////Interface_Var_Decl : variables=Variable_List ':' initialization=Interface_Type_Access;
		////Variable_List : variables+=Variable_Name ( ',' variables+=Variable_Name )*;
		////Array_Var_Decl_Init : variables=Variable_List ':' initialization=Array_Spec_Init;
		////Array_Conformand : 'ARRAY' '[' '*' ( ',' '*' )* ']' 'OF' dataType=Data_Type_Access;
		////Array_Conform_Decl : variables=Variable_List ':' conformand=Array_Conformand;
		////Struct_Var_Decl_Init : variables=Variable_List ':' initialization=Struct_Spec_Init;
		////FB_Decl_No_Init : (names+=FB_Name ( ',' names+=FB_Name )*) ':' type=FB_Type_Access;
		////FB_Decl_Init : fb=FB_Decl_No_Init ( ASSIGNMENT initialization=Struct_Init )?;
		////FB_Name returns EString : IDENTIFIER;
		////FB_Instance_Name : ( Namespace_Name DOT )* FB_Name '^' *;
		////Output_Decls : {Output_Decls} 'VAR_OUTPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( outputs+=Output_Decl ';' )* 
		////	'END_VAR';
		////Output_Decl : Var_Decl_Init | Array_Conform_Decl;
		////In_Out_Decls : {In_Out_Decls} 'VAR_IN_OUT' ( inouts+=In_Out_Var_Decl ';' )* 
		////	'END_VAR';
		////In_Out_Var_Decl : Var_Decl | Array_Conform_Decl | FB_Decl_No_Init;
		////Var_Decl : variables=Variable_List ':' initialization=( Simple_Spec | Str_Var_Decl | Array_Var_Decl | Struct_Var_Decl );
		////Array_Var_Decl : variables=Variable_List ':' initialization=Array_Spec;
		////Struct_Var_Decl : variables=Variable_List ':' initialization=Struct_Type_Access;
		////Var_Decls : {Var_Decls} 'VAR' (constant?='CONSTANT' ?) access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////Retain_Var_Decls : {Retain_Var_Decls} 'VAR' 'RETAIN' access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////Loc_Var_Decls : {Loc_Var_Decls} 'VAR' modifier=( 'CONSTANT' | 'RETAIN' | 'NON_RETAIN' )? ( variables+=Loc_Var_Decl ';' )* 'END_VAR';
		////Loc_Var_Decl : name=Variable_Name ? location=Located_At ':' initialization=Loc_Var_Spec_Init;
		////Temp_Var_Decls : {Temp_Var_Decls} 'VAR_TEMP' ( variables+=( Var_Decl | Ref_Var_Decl | Interface_Var_Decl ) ';' )* 'END_VAR';
		////External_Var_Decls : {External_Var_Decls} 'VAR_EXTERNAL' (constant?='Constant' ?) ( variables+=External_Decl ';' )* 'END_VAR';
		////External_Decl : name=Global_Var_Name ':' ( initialization=(Simple_Spec | Array_Spec) | type=(Struct_Type_Access | FB_Type_Access | Ref_Type_Access ));
		////Global_Var_Name returns EString : IDENTIFIER;
		////Global_Var_Decls : {Global_Var_Decls} 'VAR_GLOBAL' modifier=( 'CONSTANT' | 'RETAIN' )? ( variables+=Global_Var_Decl ';' )* 'END_VAR';
		////Global_Var_Decl : name=Global_Var_Spec ':' ( initialization=Loc_Var_Spec_Init | type=FB_Type_Access );
		////Global_Var_Spec : ( variables+=Global_Var_Name ( ',' variables+=Global_Var_Name )* ) | ( variables+=Global_Var_Name location=Located_At );
		////Loc_Var_Spec_Init : Simple_Spec_Init | Array_Spec_Init | Struct_Spec_Init | S_Byte_Str_Spec | D_Byte_Str_Spec;
		////Located_At : 'AT' Direct_Variable;
		////Str_Var_Decl : S_Byte_Str_Var_Decl | D_Byte_Str_Var_Decl;
		////S_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=S_Byte_Str_Spec;
		////S_Byte_Str_Spec : {S_Byte_Str_Spec} 'STRING' ( '[' bound=UNSIGNED_INT ']' )? ( ASSIGNMENT initialValue=S_BYTE_CHAR_STR )?;
		////D_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=D_Byte_Str_Spec;
		////D_Byte_Str_Spec : {D_Byte_Str_Spec} 'WSTRING' ( '[' bound=UNSIGNED_INT ']' )? ( ASSIGNMENT initialValue=D_BYTE_CHAR_STR )?;
		////Loc_Partly_Var_Decl : {Loc_Partly_Var_Decl} 'VAR' modifier=( 'RETAIN' | 'NON_RETAIN' )? variables+=Loc_Partly_Var * 'END_VAR';
		////Loc_Partly_Var : name=Variable_Name 'AT' '%' locationPrefix=( 'I' | 'Q' | 'M' ) '*' ':' initialization=Var_Spec ';';
		////Var_Spec : Simple_Spec | Array_Spec | Struct_Type_Access | StringVar_Spec;
		////StringVar_Spec: type=( 'STRING' | 'WSTRING' ) ( '[' bound=UNSIGNED_INT ']' )?;
		////
		////// Table 19 - Function declaration
		////Func_Name : Std_Func_Name | Derived_Func_Name;
		////Func_Access : ( Namespace_Name DOT )* Func_Name;
		////Std_Func_Name : 'TRUNC' | 'ABS' | 'SQRT' | 'LN' | 'LOG' | 'EXP'
		////| 'SIN' | 'COS' | 'TAN' | 'ASIN' | 'ACOS' | 'ATAN' | 'ATAN2 '
		////| 'ADD' | 'SUB' | 'MUL' | 'DIV' | 'MOD' | 'EXPT' | 'MOVE '
		////| 'SHL' | 'SHR' | 'ROL' | 'ROR'
		////| 'AND' | 'OR'  | 'XOR' | 'NOT'
		////| 'SEL' | 'MAX' | 'MIN' | 'LIMIT' | 'MUX '
		////| 'GT' | 'GE' | 'EQ' | 'LE' | 'LT' | 'NE'
		////| 'LEN' | 'LEFT' | 'RIGHT' | 'MID' | 'CONCAT' | 'INSERT' | 'DELETE' | 'REPLACE' | 'FIND';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: complete list above ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Derived_Func_Name returns EString : IDENTIFIER;
		////Func_Decl : 'FUNCTION' name=Derived_Func_Name ( ':' returnType=Data_Type_Access )? usings+=Using_Directive* ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
		////		'END_FUNCTION';
		////IO_Var_Decls : Input_Decls | Output_Decls | In_Out_Decls;
		////Func_Var_Decls : External_Var_Decls | Var_Decls;
		////
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: other languages on list below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Func_Body : / *Ladder_Diagram | FB_Diagram | Instruction_List |* / Stmt_List;// | Other_Languages;
		////
		////
		////// Table 40 – Function block type declaration
		////
		////// Table 41 - Function block instance declaration
		////FB_Type_Name : Std_FB_Name | Derived_FB_Name;
		////FB_Type_Access : ( Namespace_Name DOT )* FB_Type_Name;
		////Std_FB_Name : 'SR' | 'RS' | 'R_TRIG' | 'F_TRIG' | 'CTU'| 'CTD' | 'CTUD' | 'TP' | 'TON' | 'TOF';
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: complete list above ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Derived_FB_Name returns EString : IDENTIFIER;
		////FB_Decl : 'FUNCTION_BLOCK' modifier=( 'FINAL' | 'ABSTRACT' )? name=Derived_FB_Name usings+=Using_Directive* ( 'EXTENDS' extends=( FB_Type_Access | Class_Type_Access ) )?
		////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( ios+=FB_IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls )*
		////	( methods+=Method_Decl )* body=FB_Body ? 
		////	'END_FUNCTION_BLOCK';
		////FB_IO_Var_Decls : FB_Input_Decls | FB_Output_Decls | In_Out_Decls;
		////FB_Input_Decls : {FB_Input_Decls} 'VAR_INPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Input_Decl ';' )* 'END_VAR';
		////FB_Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
		////FB_Output_Decls : {FB_Output_Decls} 'VAR_OUTPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Output_Decl ';' )* 'END_VAR';
		////FB_Output_Decl : Var_Decl_Init | Array_Conform_Decl;
		////Other_Var_Decls : Retain_Var_Decls | No_Retain_Var_Decls | Loc_Partly_Var_Decl;
		////No_Retain_Var_Decls : {No_Retain_Var_Decls} 'VAR' 'NON_RETAIN' access=Access_Spec ? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
		////
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: other languages on list below ^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////FB_Body : Stmt_List; //| SFC | Ladder_Diagram | FB_Diagram | Instruction_List | Other_Languages;
		////Method_Decl : 'METHOD' access=Access_Spec type=( 'FINAL' | 'ABSTRACT' )? override?='OVERRIDE'?
		////	name=Method_Name ( ':' returnType=Data_Type_Access )? ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
		////	'END_METHOD';
		////Method_Name returns EString : IDENTIFIER;
		////
		////// Table 48 - Class
		////
		////// Table 50 Textual call of methods – Formal and non-formal parameter list
		////Class_Decl : 'CLASS' modifier=( 'FINAL' | 'ABSTRACT' )? name=Class_Type_Name usings+=Using_Directive* ( 'EXTENDS' extends=Class_Type_Access )? 
		////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( variables+=Func_Var_Decls | others+=Other_Var_Decls )* ( methods+=Method_Decl )* 
		////	'END_CLASS';
		////Class_Type_Name returns EString : IDENTIFIER;
		////Class_Type_Access : ( Namespace_Name DOT )* Class_Type_Name;
		////Class_Name returns EString : IDENTIFIER;
		////Class_Instance_Name : ( Namespace_Name DOT )* Class_Name '^' *;
		////Interface_Decl : 'INTERFACE' name=Interface_Type_Name usings+=Using_Directive* 
		////	( 'EXTENDS' extends+=Interface_Name_List )? 
		////	methods+=Method_Prototype* 
		////	'END_INTERFACE';
		////Method_Prototype : 'METHOD' name=Method_Name ( ':' returnType=Data_Type_Access )? ios+=IO_Var_Decls* 
		////	'END_METHOD';
		////Interface_Spec_Init : variables=Variable_List ( ASSIGNMENT initialization=Interface_Value )?;
		////Interface_Value : ((variable=Symbolic_Variable) | variableName=(FB_Instance_Name | Class_Instance_Name | 'NULL'));
		////Interface_Name_List : interfaces+=Interface_Type_Access ( ',' interfaces+=Interface_Type_Access )*;
		////Interface_Type_Name returns EString : IDENTIFIER;
		////Interface_Type_Access : ( Namespace_Name DOT )* Interface_Type_Name;
		////Interface_Name returns EString : IDENTIFIER;
		////Access_Spec : 'PUBLIC' | 'PROTECTED' | 'PRIVATE' | 'INTERNAL';
		////
		////// Table 47 - Program declaration
		////Prog_Decl : 'PROGRAM' name=Prog_Type_Name
		////	( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls | locals+=Loc_Var_Decls | acesses+=Prog_Access_Decls )* 
		////body=FB_Body 'END_PROGRAM';
		////Prog_Type_Name returns EString : IDENTIFIER;
		////Prog_Type_Access : ( Namespace_Name DOT )* Prog_Type_Name;
		////Prog_Access_Decls : {Prog_Access_Decls} 'VAR_ACCESS' ( accesses+=Prog_Access_Decl ';' )* 'END_VAR';
		////Prog_Access_Decl : name=Access_Name ':' variable=Symbolic_Variable access=Multibit_Part_Access? ':' dataType=Data_Type_Access direction=Access_Direction?;
		////
		////// Table 62 - Configuration and resource declaration
		//////Config_Name returns EString : IDENTIFIER;
		//////Resource_Type_Name returns EString : IDENTIFIER;
		//////Config_Decl : 'CONFIGURATION' Config_Name Global_Var_Decls ?
		//////( Single_Resource_Decl | Resource_Decl + ) Access_Decls ? Config_Init ?
		//////'END_CONFIGURATION';
		//////Resource_Decl : 'RESOURCE' Resource_Name 'ON' Resource_Type_Name
		//////Global_Var_Decls ? Single_Resource_Decl
		//////'END_RESOURCE';
		//////Single_Resource_Decl : ( Task_Config ';' )* ( Prog_Config ';' )+;
		//////Resource_Name returns EString : IDENTIFIER;
		//////Access_Decls : 'VAR_ACCESS' ( Access_Decl ';' )* 'END_VAR';
		//////Access_Decl : Access_Name ':' Access_Path ':' Data_Type_Access Access_Direction ?;
		//////Access_Path : ( Resource_Name DOT )? Direct_Variable
		//////| ( Resource_Name DOT )? ( Prog_Name DOT )?
		//////( ( FB_Instance_Name | Class_Instance_Name ) DOT )* Symbolic_Variable;
		//////Global_Var_Access : ( Resource_Name DOT )? Global_Var_Name ( DOT Struct_Elem_Name )?;
		////Access_Name returns EString : IDENTIFIER;
		//////Prog_Output_Access : Prog_Name DOT Symbolic_Variable;
		//////Prog_Name returns EString : IDENTIFIER;
		////Access_Direction : 'READ_WRITE' | 'READ_ONLY';
		//////Task_Config : 'TASK' Task_Name Task_Init;
		//////Task_Name returns EString : IDENTIFIER;
		//////Task_Init : '(' ( 'SINGLE' ASSIGNMENT Data_Source ',' )?
		//////( 'INTERVAL' ASSIGNMENT Data_Source ',' )?
		//////'PRIORITY' ASSIGNMENT UNSIGNED_INT ')';
		//////Data_Source : Constant | Global_Var_Access | Prog_Output_Access | Direct_Variable;
		//////Prog_Config : 'PROGRAM' ( 'RETAIN' | 'NON_RETAIN' )? Prog_Name ( 'WITH' Task_Name )? ':'
		//////Prog_Type_Access ( '(' Prog_Conf_Elems ')' )?;
		//////Prog_Conf_Elems : Prog_Conf_Elem ( ',' Prog_Conf_Elem )*;
		//////Prog_Conf_Elem : FB_Task | Prog_Cnxn;
		//////FB_Task : FB_Instance_Name 'WITH' Task_Name;
		//////Prog_Cnxn : Symbolic_Variable ASSIGNMENT Prog_Data_Source | Symbolic_Variable '=>' Data_Sink;
		//////Prog_Data_Source : Constant | Enum_Value | Global_Var_Access | Direct_Variable;
		//////Data_Sink : Global_Var_Access | Direct_Variable;
		//////Config_Init : 'VAR_CONFIG' ( Config_Inst_Init ';' )* 'END_VAR';
		//////Config_Inst_Init : Resource_Name DOT Prog_Name DOT ( ( FB_Instance_Name | Class_Instance_Name ) DOT )*
		//////( Variable_Name Located_At ? ':' Loc_Var_Spec_Init
		//////| ( ( FB_Instance_Name ':' FB_Type_Access )
		//////| ( Class_Instance_Name ':' Class_Type_Access ) ) ASSIGNMENT Struct_Init );
		//////
		//////// Table 64 - Namespace
		//////Namespace_Decl : 'NAMESPACE' 'INTERNAL' ? Namespace_H_Name Using_Directive * Namespace_Elements
		//////'END_NAMESPACE';
		//////Namespace_Elements : ( Data_Type_Decl | Func_Decl | FB_Decl
		//////| Class_Decl | Interface_Decl | Namespace_Decl )+;
		////Namespace_H_Name : qualifier+=Namespace_Name ( DOT qualifier+=Namespace_Name )*;
		////Using_Directive : 'USING' namespaces+=Namespace_H_Name ( ',' namespaces+=Namespace_H_Name )* ';';
		//////POU_Decl : Using_Directive *
		//////( Global_Var_Decls | Data_Type_Decl | Access_Decls
		//////| Func_Decl | FB_Decl | Class_Decl | Interface_Decl
		//////| Namespace_Decl )+;
		//////
		////
		////// Table 71 - 72 - Language Structured Text (ST)
		////Expression returns Expression: Xor_Expr ({Expression.left=current} operator='OR' right=Xor_Expr )*;
		////// a constant expression must evaluate to a constant value at compile time
		////Constant_Expr : Expression;
		////Xor_Expr returns Expression: And_Expr ({Xor_Expr.left=current} operator='XOR' right=And_Expr )*;
		////And_Expr returns Expression: Compare_Expr ({And_Expr.left=current} operator=( '&' | 'AND' ) right=Compare_Expr )*;
		////Compare_Expr returns Expression: Equ_Expr ({Compare_Expr.left=current} operator=( '=' | '<>' ) right=Equ_Expr )*;
		////Equ_Expr returns Expression: Add_Expr ({Equ_Expr.left=current} operator=( '<' | '>' | '<=' | '>=' ) right=Add_Expr )*;
		////Add_Expr returns Expression: Term ({Add_Expr.left=current} operator=( '+' | '-' ) right=Term )*;
		////Term returns Expression: Power_Expr ({Term.left=current} operator=('*' | '/' | 'MOD') right=Power_Expr )*;
		////Power_Expr returns Expression: Unary_Expr ({Power_Expr.left=current} operator='**' right=Unary_Expr )*;
		////Unary_Expr returns Expression: operator=('-' | '+' | 'NOT')? expression=Primary_Expr;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call |  Ref_Value | '(' Expression ')'^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Primary_Expr returns Expression: {Expression} Constant | Enum_Value | Variable_Access / * | Func_Call |  Ref_Value | '(' Expression ')' * /;
		////
		////Variable_Access : variable=Variable access=Multibit_Part_Access ?;
		////Multibit_Part_Access : DOT ( accessSize=UNSIGNED_INT | accessSizeInfo=Size_Info );
		////Size_Info : '%' sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' ) ? size=UNSIGNED_INT;
		////Func_Call : access=Func_Access '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////Stmt_List : {Stmt_List} ( statement+=Stmt ? ';' )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Assign_Stmt | Subprog_Ctrl_Stmt |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Stmt : / * Assign_Stmt | Subprog_Ctrl_Stmt | * / Selection_Stmt | Iteration_Stmt;
		////Assign_Stmt : Variable_Assign_Stmt | Ref_Assign | Assignment_Attempt;
		////Variable_Assign_Stmt : left=Variable ASSIGNMENT right=Expression;
		////Assignment_Attempt : ( leftName=Ref_Name | leftReference=Ref_Deref ) '?=' ( rightName=Ref_Name | rightReference=(Ref_Deref | Ref_Value) );
		////Invocation : method=( FB_Instance_Name | Method_Name | 'THIS' | Qualified_Method_Call ) '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////Qualified_Method_Call : ( ( 'THIS' DOT )? ( ( ( FB_Instance_Name | Class_Instance_Name ) DOT )+ ) Method_Name );
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Subprog_Ctrl_Stmt : / * Func_Call | Invocation | * / Super_Invocation | Return;
		////Sub_Invocation: Super_Invocation | Return;
		////Super_Invocation : 'SUPER' '(' ')';
		////Return : 'RETURN';
		////Param_Assign : Named_Value | Ref_Assign | Linked_Value;
		////Named_Value : ( name=Variable_Name ASSIGNMENT )? value=Expression;
		////Linked_Value : (negated?='NOT')? name=Variable_Name '=>' value=Variable;
		////Selection_Stmt : IF_Stmt | Case_Stmt;
		////IF_Stmt : 'IF' condition=Expression 'THEN' statements=Stmt_List ( elseifs+=ELSEIF_Stmt )* ( else=ELSE_Stmt )? 'END_IF';
		////ELSEIF_Stmt : 'ELSIF' condition=Expression 'THEN' statements=Stmt_List;
		////ELSE_Stmt: 'ELSE' statements=Stmt_List;
		////Case_Stmt : 'CASE' expression=Expression 'OF' cases+=Case_Selection + ( 'ELSE' defaultStatements=Stmt_List )? 'END_CASE';
		////Case_Selection : values=Case_List ':' statements=Stmt_List;
		////Case_List : caseValues+=Case_List_Elem ( ',' caseValues+=Case_List_Elem )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Case_List_Elem : Subrange / *| Constant_Expr* /;
		////Iteration_Stmt : For_Stmt | While_Stmt | Repeat_Stmt | Exit_Stmt | Continue_Stmt;
		////Exit_Stmt : {Exit_Stmt} 'EXIT';
		////Continue_Stmt : {Continue_Stmt} 'CONTINUE';
		////For_Stmt : 'FOR' variable=Control_Variable ASSIGNMENT bounds=For_List 'DO' statements=Stmt_List 'END_FOR';
		////Control_Variable returns EString : IDENTIFIER;
		////For_List : lowBound=Expression 'TO' upBound=Expression ( 'BY' step=Expression )?;
		////While_Stmt : 'WHILE' condition=Expression 'DO' statements=Stmt_List 'END_WHILE';
		////Repeat_Stmt : 'REPEAT' statements=Stmt_List 'UNTIL' condition=Expression 'END_REPEAT'; Namespace_Name returns EString:
		//	IDENTIFIER;
		public ParserRule getRule() { return rule; }

		////Using_Directive : 'USING' namespaces+=Namespace_H_Name ( ',' namespaces+=Namespace_H_Name )* ';';
		//////POU_Decl : Using_Directive *
		//////( Global_Var_Decls | Data_Type_Decl | Access_Decls
		//////| Func_Decl | FB_Decl | Class_Decl | Interface_Decl
		//////| Namespace_Decl )+;
		//////
		////
		////// Table 71 - 72 - Language Structured Text (ST)
		////Expression returns Expression: Xor_Expr ({Expression.left=current} operator='OR' right=Xor_Expr )*;
		////// a constant expression must evaluate to a constant value at compile time
		////Constant_Expr : Expression;
		////Xor_Expr returns Expression: And_Expr ({Xor_Expr.left=current} operator='XOR' right=And_Expr )*;
		////And_Expr returns Expression: Compare_Expr ({And_Expr.left=current} operator=( '&' | 'AND' ) right=Compare_Expr )*;
		////Compare_Expr returns Expression: Equ_Expr ({Compare_Expr.left=current} operator=( '=' | '<>' ) right=Equ_Expr )*;
		////Equ_Expr returns Expression: Add_Expr ({Equ_Expr.left=current} operator=( '<' | '>' | '<=' | '>=' ) right=Add_Expr )*;
		////Add_Expr returns Expression: Term ({Add_Expr.left=current} operator=( '+' | '-' ) right=Term )*;
		////Term returns Expression: Power_Expr ({Term.left=current} operator=('*' | '/' | 'MOD') right=Power_Expr )*;
		////Power_Expr returns Expression: Unary_Expr ({Power_Expr.left=current} operator='**' right=Unary_Expr )*;
		////Unary_Expr returns Expression: operator=('-' | '+' | 'NOT')? expression=Primary_Expr;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call |  Ref_Value | '(' Expression ')'^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Primary_Expr returns Expression: {Expression} Constant | Enum_Value | Variable_Access / * | Func_Call |  Ref_Value | '(' Expression ')' * /;
		////
		////Variable_Access : variable=Variable access=Multibit_Part_Access ?;
		////Multibit_Part_Access : DOT ( accessSize=UNSIGNED_INT | accessSizeInfo=Size_Info );
		////Size_Info : '%' sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' ) ? size=UNSIGNED_INT;
		////Func_Call : access=Func_Access '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////Stmt_List : {Stmt_List} ( statement+=Stmt ? ';' )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Assign_Stmt | Subprog_Ctrl_Stmt |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Stmt : / * Assign_Stmt | Subprog_Ctrl_Stmt | * / Selection_Stmt | Iteration_Stmt;
		////Assign_Stmt : Variable_Assign_Stmt | Ref_Assign | Assignment_Attempt;
		////Variable_Assign_Stmt : left=Variable ASSIGNMENT right=Expression;
		////Assignment_Attempt : ( leftName=Ref_Name | leftReference=Ref_Deref ) '?=' ( rightName=Ref_Name | rightReference=(Ref_Deref | Ref_Value) );
		////Invocation : method=( FB_Instance_Name | Method_Name | 'THIS' | Qualified_Method_Call ) '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
		////Qualified_Method_Call : ( ( 'THIS' DOT )? ( ( ( FB_Instance_Name | Class_Instance_Name ) DOT )+ ) Method_Name );
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Subprog_Ctrl_Stmt : / * Func_Call | Invocation | * / Super_Invocation | Return;
		////Sub_Invocation: Super_Invocation | Return;
		////Super_Invocation : 'SUPER' '(' ')';
		////Return : 'RETURN';
		////Param_Assign : Named_Value | Ref_Assign | Linked_Value;
		////Named_Value : ( name=Variable_Name ASSIGNMENT )? value=Expression;
		////Linked_Value : (negated?='NOT')? name=Variable_Name '=>' value=Variable;
		////Selection_Stmt : IF_Stmt | Case_Stmt;
		////IF_Stmt : 'IF' condition=Expression 'THEN' statements=Stmt_List ( elseifs+=ELSEIF_Stmt )* ( else=ELSE_Stmt )? 'END_IF';
		////ELSEIF_Stmt : 'ELSIF' condition=Expression 'THEN' statements=Stmt_List;
		////ELSE_Stmt: 'ELSE' statements=Stmt_List;
		////Case_Stmt : 'CASE' expression=Expression 'OF' cases+=Case_Selection + ( 'ELSE' defaultStatements=Stmt_List )? 'END_CASE';
		////Case_Selection : values=Case_List ':' statements=Stmt_List;
		////Case_List : caseValues+=Case_List_Elem ( ',' caseValues+=Case_List_Elem )*;
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////// *******************************************************
		////Case_List_Elem : Subrange / *| Constant_Expr* /;
		////Iteration_Stmt : For_Stmt | While_Stmt | Repeat_Stmt | Exit_Stmt | Continue_Stmt;
		////Exit_Stmt : {Exit_Stmt} 'EXIT';
		////Continue_Stmt : {Continue_Stmt} 'CONTINUE';
		////For_Stmt : 'FOR' variable=Control_Variable ASSIGNMENT bounds=For_List 'DO' statements=Stmt_List 'END_FOR';
		////Control_Variable returns EString : IDENTIFIER;
		////For_List : lowBound=Expression 'TO' upBound=Expression ( 'BY' step=Expression )?;
		////While_Stmt : 'WHILE' condition=Expression 'DO' statements=Stmt_List 'END_WHILE';
		////Repeat_Stmt : 'REPEAT' statements=Stmt_List 'UNTIL' condition=Expression 'END_REPEAT'; IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall() { return cIDENTIFIERTerminalRuleCall; }
	}
	
	
	private TestElements pTest;
	private TerminalRule tUNDERSCORE;
	private TerminalRule tLETTER;
	private TerminalRule tDIGIT;
	private TerminalRule tBIT;
	private TerminalRule tOCTAL_DIGIT;
	private TerminalRule tHEX_DIGIT;
	private TerminalRule tIDENTIFIER;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tML_COMMENT_1;
	private TerminalRule tML_COMMENT_2;
	private TerminalRule tCOMMENT;
	private TerminalRule tWS;
	private TerminalRule tEOL;
	private TerminalRule tPRAGMA;
	private CONSTANTElements pCONSTANT;
	private TerminalRule tNUMERIC_LITERAL;
	private TerminalRule tINT_LITERAL;
	private TerminalRule tUNSIGNED_INT;
	private TerminalRule tSIGNED_INT;
	private TerminalRule tBINARY_INT;
	private TerminalRule tOCTAL_INT;
	private TerminalRule tHEX_INT;
	private TerminalRule tREAL_LITERAL;
	private TerminalRule tBIT_STR_LITERAL;
	private TerminalRule tBOOL_LITERAL;
	private TerminalRule tCHAR_LITERAL;
	private TerminalRule tCHAR_STR;
	private TerminalRule tS_BYTE_CHAR_STR;
	private TerminalRule tD_BYTE_CHAR_STR;
	private TerminalRule tS_BYTE_CHAR_VALUE;
	private TerminalRule tD_BYTE_CHAR_VALUE;
	private TerminalRule tCOMMON_CHAR_VALUE;
	private TerminalRule tASSIGNMENT;
	private TerminalRule tDOT;
	private TIME_LITERALElements pTIME_LITERAL;
	private DURATIONElements pDURATION;
	private TerminalRule tFIX_POINT;
	private INTERVALElements pINTERVAL;
	private TerminalRule tDAYS;
	private TerminalRule tDAY_FLOAT;
	private TerminalRule tDAY_UNSIGNED;
	private TerminalRule tHOURS;
	private TerminalRule tHOUR_FLOAT;
	private TerminalRule tHOUR_UNSIGNED;
	private TerminalRule tMINUTES;
	private TerminalRule tMINUTE_FLOAT;
	private TerminalRule tMINUTE_UNSIGNED;
	private TerminalRule tSECONDS;
	private TerminalRule tSECOND_FLOAT;
	private TerminalRule tSECOND_UNSIGNED;
	private TerminalRule tMILLISECONDS;
	private TerminalRule tMILLISECOND_FLOAT;
	private TerminalRule tMILLISECOND_UNSIGNED;
	private TerminalRule tMICROSECONDS;
	private TerminalRule tMICROSECOND_FLOAT;
	private TerminalRule tMICROSECOND_UNSIGNED;
	private TerminalRule tNANOSECONDS;
	private TerminalRule tTIME_OF_DAY;
	private TerminalRule tDAYTIME;
	private TerminalRule tDAY_HOUR;
	private TerminalRule tDAY_MINUTE;
	private TerminalRule tDAY_SECOND;
	private TerminalRule tDATE;
	private TerminalRule tDATE_LITERAL;
	private TerminalRule tYEAR;
	private TerminalRule tMONTH;
	private TerminalRule tDAY;
	private TerminalRule tDATE_AND_TIME;
	private TerminalRule tELEM_TYPE_NAME;
	private TerminalRule tNUMERIC_TYPE_NAME;
	private TerminalRule tINT_TYPE_NAME;
	private TerminalRule tSIGN_INT_TYPE_NAME;
	private TerminalRule tUNSIGN_INT_TYPE_NAME;
	private TerminalRule tREAL_TYPE_NAME;
	private TerminalRule tSTRING_TYPE_NAME;
	private TerminalRule tTIME_TYPE_NAME;
	private TerminalRule tDATE_TYPE_NAME;
	private TerminalRule tTOD_TYPE_NAME;
	private TerminalRule tDT_TYPE_NAME;
	private TerminalRule tBIT_STR_TYPE_NAME;
	private TerminalRule tBOOL_TYPE_NAME;
	private TerminalRule tMULTIBITS_TYPE_NAME;
	private String_Type_AccessElements pString_Type_Access;
	private Single_Elem_Type_AccessElements pSingle_Elem_Type_Access;
	private Simple_Type_AccessElements pSimple_Type_Access;
	private Subrange_Type_AccessElements pSubrange_Type_Access;
	private Enum_Type_AccessElements pEnum_Type_Access;
	private Array_Type_AccessElements pArray_Type_Access;
	private Struct_Type_AccessElements pStruct_Type_Access;
	private Simple_Type_NameElements pSimple_Type_Name;
	private Subrange_Type_NameElements pSubrange_Type_Name;
	private Enum_Type_NameElements pEnum_Type_Name;
	private Array_Type_NameElements pArray_Type_Name;
	private Struct_Type_NameElements pStruct_Type_Name;
	private Namespace_NameElements pNamespace_Name;
	
	private final Grammar grammar;

	@Inject
	public STLanguageGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("at.bachmann.plc.st.STLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//test:
	//	test="s";
	public TestElements getTestAccess() {
		return (pTest != null) ? pTest : (pTest = new TestElements());
	}
	
	public ParserRule getTestRule() {
		return getTestAccess().getRule();
	}

	////ST_Program: Prog_Decl;
	//// Table 1 - Character sets
	//// Table 2 - IDENTIFIERs
	//terminal fragment UNDERSCORE:
	//	"_";
	public TerminalRule getUNDERSCORERule() {
		return (tUNDERSCORE != null) ? tUNDERSCORE : (tUNDERSCORE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UNDERSCORE"));
	} 

	//terminal fragment LETTER:
	//	"A".."Z" | "_";
	public TerminalRule getLETTERRule() {
		return (tLETTER != null) ? tLETTER : (tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LETTER"));
	} 

	//terminal fragment DIGIT:
	//	"0".."9";
	public TerminalRule getDIGITRule() {
		return (tDIGIT != null) ? tDIGIT : (tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT"));
	} 

	//terminal fragment BIT:
	//	"0".."1";
	public TerminalRule getBITRule() {
		return (tBIT != null) ? tBIT : (tBIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BIT"));
	} 

	//terminal fragment OCTAL_DIGIT:
	//	"0".."7";
	public TerminalRule getOCTAL_DIGITRule() {
		return (tOCTAL_DIGIT != null) ? tOCTAL_DIGIT : (tOCTAL_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OCTAL_DIGIT"));
	} 

	//terminal fragment HEX_DIGIT:
	//	"0".."9" | "A".."F";
	public TerminalRule getHEX_DIGITRule() {
		return (tHEX_DIGIT != null) ? tHEX_DIGIT : (tHEX_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX_DIGIT"));
	} 

	//terminal IDENTIFIER:
	//	LETTER (LETTER | DIGIT)*;
	public TerminalRule getIDENTIFIERRule() {
		return (tIDENTIFIER != null) ? tIDENTIFIER : (tIDENTIFIER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "IDENTIFIER"));
	} 

	//// Table 3 - Comments
	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* "\r"? "\n";
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal ML_COMMENT_1:
	//	"(*"->"*)";
	public TerminalRule getML_COMMENT_1Rule() {
		return (tML_COMMENT_1 != null) ? tML_COMMENT_1 : (tML_COMMENT_1 = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT_1"));
	} 

	//terminal ML_COMMENT_2:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENT_2Rule() {
		return (tML_COMMENT_2 != null) ? tML_COMMENT_2 : (tML_COMMENT_2 = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT_2"));
	} 

	//terminal COMMENT:
	//	SL_COMMENT | ML_COMMENT_1 | ML_COMMENT_2;
	public TerminalRule getCOMMENTRule() {
		return (tCOMMENT != null) ? tCOMMENT : (tCOMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMENT"));
	} 

	//// white space
	//terminal WS:
	//	" " | "\t" | "\r" | "\n";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal EOL:
	//	"\n";
	public TerminalRule getEOLRule() {
		return (tEOL != null) ? tEOL : (tEOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EOL"));
	} 

	//// Table 4 - Pragma
	//terminal PRAGMA:
	//	"{"->"}";
	public TerminalRule getPRAGMARule() {
		return (tPRAGMA != null) ? tPRAGMA : (tPRAGMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PRAGMA"));
	} 

	//// Table 5 - Numeric literal
	//CONSTANT:
	//	NUMERIC_LITERAL | CHAR_LITERAL | TIME_LITERAL | BIT_STR_LITERAL | BOOL_LITERAL;
	public CONSTANTElements getCONSTANTAccess() {
		return (pCONSTANT != null) ? pCONSTANT : (pCONSTANT = new CONSTANTElements());
	}
	
	public ParserRule getCONSTANTRule() {
		return getCONSTANTAccess().getRule();
	}

	//terminal NUMERIC_LITERAL:
	//	INT_LITERAL | REAL_LITERAL;
	public TerminalRule getNUMERIC_LITERALRule() {
		return (tNUMERIC_LITERAL != null) ? tNUMERIC_LITERAL : (tNUMERIC_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMERIC_LITERAL"));
	} 

	//terminal INT_LITERAL:
	//	(INT_TYPE_NAME "#")? SIGNED_INT | BINARY_INT | OCTAL_INT | HEX_INT;
	public TerminalRule getINT_LITERALRule() {
		return (tINT_LITERAL != null) ? tINT_LITERAL : (tINT_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT_LITERAL"));
	} 

	//terminal UNSIGNED_INT:
	//	DIGIT (UNDERSCORE? DIGIT)*;
	public TerminalRule getUNSIGNED_INTRule() {
		return (tUNSIGNED_INT != null) ? tUNSIGNED_INT : (tUNSIGNED_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UNSIGNED_INT"));
	} 

	//terminal SIGNED_INT:
	//	("+" | "-")? UNSIGNED_INT;
	public TerminalRule getSIGNED_INTRule() {
		return (tSIGNED_INT != null) ? tSIGNED_INT : (tSIGNED_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SIGNED_INT"));
	} 

	//terminal BINARY_INT:
	//	"2#" (UNDERSCORE? BIT)+;
	public TerminalRule getBINARY_INTRule() {
		return (tBINARY_INT != null) ? tBINARY_INT : (tBINARY_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BINARY_INT"));
	} 

	//terminal OCTAL_INT:
	//	"8#" (UNDERSCORE? OCTAL_DIGIT)+;
	public TerminalRule getOCTAL_INTRule() {
		return (tOCTAL_INT != null) ? tOCTAL_INT : (tOCTAL_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OCTAL_INT"));
	} 

	//terminal HEX_INT:
	//	"16#" (UNDERSCORE? HEX_DIGIT)+;
	public TerminalRule getHEX_INTRule() {
		return (tHEX_INT != null) ? tHEX_INT : (tHEX_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX_INT"));
	} 

	//terminal REAL_LITERAL:
	//	(REAL_TYPE_NAME "#")? SIGNED_INT DOT UNSIGNED_INT ("E" SIGNED_INT)?;
	public TerminalRule getREAL_LITERALRule() {
		return (tREAL_LITERAL != null) ? tREAL_LITERAL : (tREAL_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REAL_LITERAL"));
	} 

	//terminal BIT_STR_LITERAL:
	//	(MULTIBITS_TYPE_NAME "#")? UNSIGNED_INT | BINARY_INT | OCTAL_INT | HEX_INT;
	public TerminalRule getBIT_STR_LITERALRule() {
		return (tBIT_STR_LITERAL != null) ? tBIT_STR_LITERAL : (tBIT_STR_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BIT_STR_LITERAL"));
	} 

	//terminal BOOL_LITERAL:
	//	(BOOL_TYPE_NAME "#")? BIT | "FALSE" | "TRUE";
	public TerminalRule getBOOL_LITERALRule() {
		return (tBOOL_LITERAL != null) ? tBOOL_LITERAL : (tBOOL_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOL_LITERAL"));
	} 

	//// Table 6 - Character String literals
	//// Table 7 - Two-character combinations in character strings
	//terminal CHAR_LITERAL:
	//	"STRING#"? CHAR_STR;
	public TerminalRule getCHAR_LITERALRule() {
		return (tCHAR_LITERAL != null) ? tCHAR_LITERAL : (tCHAR_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CHAR_LITERAL"));
	} 

	//terminal CHAR_STR:
	//	S_BYTE_CHAR_STR | D_BYTE_CHAR_STR;
	public TerminalRule getCHAR_STRRule() {
		return (tCHAR_STR != null) ? tCHAR_STR : (tCHAR_STR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CHAR_STR"));
	} 

	//terminal S_BYTE_CHAR_STR:
	//	"\'" S_BYTE_CHAR_VALUE+ "\'";
	public TerminalRule getS_BYTE_CHAR_STRRule() {
		return (tS_BYTE_CHAR_STR != null) ? tS_BYTE_CHAR_STR : (tS_BYTE_CHAR_STR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "S_BYTE_CHAR_STR"));
	} 

	//terminal D_BYTE_CHAR_STR:
	//	"\"" D_BYTE_CHAR_VALUE+ "\"";
	public TerminalRule getD_BYTE_CHAR_STRRule() {
		return (tD_BYTE_CHAR_STR != null) ? tD_BYTE_CHAR_STR : (tD_BYTE_CHAR_STR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "D_BYTE_CHAR_STR"));
	} 

	//terminal S_BYTE_CHAR_VALUE:
	//	COMMON_CHAR_VALUE | "$\'" | "\"" | "$" HEX_DIGIT HEX_DIGIT;
	public TerminalRule getS_BYTE_CHAR_VALUERule() {
		return (tS_BYTE_CHAR_VALUE != null) ? tS_BYTE_CHAR_VALUE : (tS_BYTE_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "S_BYTE_CHAR_VALUE"));
	} 

	//terminal D_BYTE_CHAR_VALUE:
	//	COMMON_CHAR_VALUE | "\'" | "$\"" | "$" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
	public TerminalRule getD_BYTE_CHAR_VALUERule() {
		return (tD_BYTE_CHAR_VALUE != null) ? tD_BYTE_CHAR_VALUE : (tD_BYTE_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "D_BYTE_CHAR_VALUE"));
	} 

	//// any printable characters except $, " and '
	//terminal fragment COMMON_CHAR_VALUE:
	//	" " | "!" | "#" | "%" | "&" | "(".."/" | "0".."9" | ":".."@" | "A".."Z" | "[".."`" | "a".."z" | "{".."~" | "$$" |
	//	"$L" | "$N" | "$P" | "$R" | "$T";
	public TerminalRule getCOMMON_CHAR_VALUERule() {
		return (tCOMMON_CHAR_VALUE != null) ? tCOMMON_CHAR_VALUE : (tCOMMON_CHAR_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMON_CHAR_VALUE"));
	} 

	//terminal ASSIGNMENT:
	//	":=";
	public TerminalRule getASSIGNMENTRule() {
		return (tASSIGNMENT != null) ? tASSIGNMENT : (tASSIGNMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ASSIGNMENT"));
	} 

	//terminal DOT:
	//	".";
	public TerminalRule getDOTRule() {
		return (tDOT != null) ? tDOT : (tDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOT"));
	} 

	//// Table 8 - DURATION literals
	//// Table 9 – DATE and time of day literals
	//TIME_LITERAL:
	//	DURATION | TIME_OF_DAY | DATE | DATE_AND_TIME;
	public TIME_LITERALElements getTIME_LITERALAccess() {
		return (pTIME_LITERAL != null) ? pTIME_LITERAL : (pTIME_LITERAL = new TIME_LITERALElements());
	}
	
	public ParserRule getTIME_LITERALRule() {
		return getTIME_LITERALAccess().getRule();
	}

	//DURATION:
	//	(TIME_TYPE_NAME | "T" | "LT") "#" ("+" | "-")? INTERVAL;
	public DURATIONElements getDURATIONAccess() {
		return (pDURATION != null) ? pDURATION : (pDURATION = new DURATIONElements());
	}
	
	public ParserRule getDURATIONRule() {
		return getDURATIONAccess().getRule();
	}

	//terminal FIX_POINT:
	//	UNSIGNED_INT (DOT UNSIGNED_INT)?;
	public TerminalRule getFIX_POINTRule() {
		return (tFIX_POINT != null) ? tFIX_POINT : (tFIX_POINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FIX_POINT"));
	} 

	//INTERVAL:
	//	DAYS | HOURS | MINUTES | SECONDS | MILLISECONDS | MICROSECONDS | NANOSECONDS;
	public INTERVALElements getINTERVALAccess() {
		return (pINTERVAL != null) ? pINTERVAL : (pINTERVAL = new INTERVALElements());
	}
	
	public ParserRule getINTERVALRule() {
		return getINTERVALAccess().getRule();
	}

	//terminal DAYS:
	//	DAY_UNSIGNED | DAY_FLOAT;
	public TerminalRule getDAYSRule() {
		return (tDAYS != null) ? tDAYS : (tDAYS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAYS"));
	} 

	//terminal DAY_FLOAT:
	//	FIX_POINT "d";
	public TerminalRule getDAY_FLOATRule() {
		return (tDAY_FLOAT != null) ? tDAY_FLOAT : (tDAY_FLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAY_FLOAT"));
	} 

	//terminal DAY_UNSIGNED:
	//	(UNSIGNED_INT "d" UNDERSCORE?)? HOURS?;
	public TerminalRule getDAY_UNSIGNEDRule() {
		return (tDAY_UNSIGNED != null) ? tDAY_UNSIGNED : (tDAY_UNSIGNED = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAY_UNSIGNED"));
	} 

	//terminal HOURS:
	//	HOUR_UNSIGNED | HOUR_FLOAT;
	public TerminalRule getHOURSRule() {
		return (tHOURS != null) ? tHOURS : (tHOURS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HOURS"));
	} 

	//terminal HOUR_FLOAT:
	//	FIX_POINT "h";
	public TerminalRule getHOUR_FLOATRule() {
		return (tHOUR_FLOAT != null) ? tHOUR_FLOAT : (tHOUR_FLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HOUR_FLOAT"));
	} 

	//terminal HOUR_UNSIGNED:
	//	(UNSIGNED_INT "h" UNDERSCORE?)? MINUTES?;
	public TerminalRule getHOUR_UNSIGNEDRule() {
		return (tHOUR_UNSIGNED != null) ? tHOUR_UNSIGNED : (tHOUR_UNSIGNED = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HOUR_UNSIGNED"));
	} 

	//terminal MINUTES:
	//	MINUTE_UNSIGNED | MINUTE_FLOAT;
	public TerminalRule getMINUTESRule() {
		return (tMINUTES != null) ? tMINUTES : (tMINUTES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINUTES"));
	} 

	//terminal MINUTE_FLOAT:
	//	FIX_POINT "m";
	public TerminalRule getMINUTE_FLOATRule() {
		return (tMINUTE_FLOAT != null) ? tMINUTE_FLOAT : (tMINUTE_FLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINUTE_FLOAT"));
	} 

	//terminal MINUTE_UNSIGNED:
	//	(UNSIGNED_INT "m" UNDERSCORE?)? SECONDS?;
	public TerminalRule getMINUTE_UNSIGNEDRule() {
		return (tMINUTE_UNSIGNED != null) ? tMINUTE_UNSIGNED : (tMINUTE_UNSIGNED = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINUTE_UNSIGNED"));
	} 

	//terminal SECONDS:
	//	SECOND_UNSIGNED | SECOND_FLOAT;
	public TerminalRule getSECONDSRule() {
		return (tSECONDS != null) ? tSECONDS : (tSECONDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SECONDS"));
	} 

	//terminal SECOND_FLOAT:
	//	FIX_POINT "s";
	public TerminalRule getSECOND_FLOATRule() {
		return (tSECOND_FLOAT != null) ? tSECOND_FLOAT : (tSECOND_FLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SECOND_FLOAT"));
	} 

	//terminal SECOND_UNSIGNED:
	//	(UNSIGNED_INT "s" UNDERSCORE?)? MILLISECONDS?;
	public TerminalRule getSECOND_UNSIGNEDRule() {
		return (tSECOND_UNSIGNED != null) ? tSECOND_UNSIGNED : (tSECOND_UNSIGNED = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SECOND_UNSIGNED"));
	} 

	//terminal MILLISECONDS:
	//	MILLISECOND_UNSIGNED | MILLISECOND_FLOAT;
	public TerminalRule getMILLISECONDSRule() {
		return (tMILLISECONDS != null) ? tMILLISECONDS : (tMILLISECONDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MILLISECONDS"));
	} 

	//terminal MILLISECOND_FLOAT:
	//	FIX_POINT "ms";
	public TerminalRule getMILLISECOND_FLOATRule() {
		return (tMILLISECOND_FLOAT != null) ? tMILLISECOND_FLOAT : (tMILLISECOND_FLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MILLISECOND_FLOAT"));
	} 

	//terminal MILLISECOND_UNSIGNED:
	//	(UNSIGNED_INT "ms" UNDERSCORE?)? MICROSECONDS?;
	public TerminalRule getMILLISECOND_UNSIGNEDRule() {
		return (tMILLISECOND_UNSIGNED != null) ? tMILLISECOND_UNSIGNED : (tMILLISECOND_UNSIGNED = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MILLISECOND_UNSIGNED"));
	} 

	//terminal MICROSECONDS:
	//	MICROSECOND_UNSIGNED | MICROSECOND_FLOAT;
	public TerminalRule getMICROSECONDSRule() {
		return (tMICROSECONDS != null) ? tMICROSECONDS : (tMICROSECONDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MICROSECONDS"));
	} 

	//terminal MICROSECOND_FLOAT:
	//	FIX_POINT "us";
	public TerminalRule getMICROSECOND_FLOATRule() {
		return (tMICROSECOND_FLOAT != null) ? tMICROSECOND_FLOAT : (tMICROSECOND_FLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MICROSECOND_FLOAT"));
	} 

	//terminal MICROSECOND_UNSIGNED:
	//	(UNSIGNED_INT "us" UNDERSCORE?)? NANOSECONDS?;
	public TerminalRule getMICROSECOND_UNSIGNEDRule() {
		return (tMICROSECOND_UNSIGNED != null) ? tMICROSECOND_UNSIGNED : (tMICROSECOND_UNSIGNED = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MICROSECOND_UNSIGNED"));
	} 

	//terminal NANOSECONDS:
	//	FIX_POINT "ns";
	public TerminalRule getNANOSECONDSRule() {
		return (tNANOSECONDS != null) ? tNANOSECONDS : (tNANOSECONDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NANOSECONDS"));
	} 

	//terminal TIME_OF_DAY:
	//	(TOD_TYPE_NAME | "LTIME_OF_DAY") "#" DAYTIME;
	public TerminalRule getTIME_OF_DAYRule() {
		return (tTIME_OF_DAY != null) ? tTIME_OF_DAY : (tTIME_OF_DAY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TIME_OF_DAY"));
	} 

	//terminal DAYTIME:
	//	DAY_HOUR ":" DAY_MINUTE ":" DAY_SECOND;
	public TerminalRule getDAYTIMERule() {
		return (tDAYTIME != null) ? tDAYTIME : (tDAYTIME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAYTIME"));
	} 

	//terminal DAY_HOUR:
	//	UNSIGNED_INT;
	public TerminalRule getDAY_HOURRule() {
		return (tDAY_HOUR != null) ? tDAY_HOUR : (tDAY_HOUR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAY_HOUR"));
	} 

	//terminal DAY_MINUTE:
	//	UNSIGNED_INT;
	public TerminalRule getDAY_MINUTERule() {
		return (tDAY_MINUTE != null) ? tDAY_MINUTE : (tDAY_MINUTE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAY_MINUTE"));
	} 

	//terminal DAY_SECOND:
	//	FIX_POINT;
	public TerminalRule getDAY_SECONDRule() {
		return (tDAY_SECOND != null) ? tDAY_SECOND : (tDAY_SECOND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAY_SECOND"));
	} 

	//terminal DATE:
	//	(DATE_TYPE_NAME | "D" | "LD") "#" DATE_LITERAL;
	public TerminalRule getDATERule() {
		return (tDATE != null) ? tDATE : (tDATE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DATE"));
	} 

	//terminal DATE_LITERAL:
	//	YEAR "-" MONTH "-" DAY;
	public TerminalRule getDATE_LITERALRule() {
		return (tDATE_LITERAL != null) ? tDATE_LITERAL : (tDATE_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DATE_LITERAL"));
	} 

	//terminal YEAR:
	//	UNSIGNED_INT;
	public TerminalRule getYEARRule() {
		return (tYEAR != null) ? tYEAR : (tYEAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "YEAR"));
	} 

	//terminal MONTH:
	//	UNSIGNED_INT;
	public TerminalRule getMONTHRule() {
		return (tMONTH != null) ? tMONTH : (tMONTH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MONTH"));
	} 

	//terminal DAY:
	//	UNSIGNED_INT;
	public TerminalRule getDAYRule() {
		return (tDAY != null) ? tDAY : (tDAY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DAY"));
	} 

	//terminal DATE_AND_TIME:
	//	(DT_TYPE_NAME | "LDATE_AND_TIME") "#" DATE_LITERAL "-" DAYTIME;
	public TerminalRule getDATE_AND_TIMERule() {
		return (tDATE_AND_TIME != null) ? tDATE_AND_TIME : (tDATE_AND_TIME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DATE_AND_TIME"));
	} 

	//// Table 10 - Elementary data types
	////Data_Type_Access : type=(ELEM_TYPE_NAME | Derived_Type_Access);
	//terminal ELEM_TYPE_NAME:
	//	NUMERIC_TYPE_NAME | BIT_STR_TYPE_NAME | STRING_TYPE_NAME | DATE_TYPE_NAME | TIME_TYPE_NAME;
	public TerminalRule getELEM_TYPE_NAMERule() {
		return (tELEM_TYPE_NAME != null) ? tELEM_TYPE_NAME : (tELEM_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ELEM_TYPE_NAME"));
	} 

	//terminal NUMERIC_TYPE_NAME:
	//	INT_TYPE_NAME | REAL_TYPE_NAME;
	public TerminalRule getNUMERIC_TYPE_NAMERule() {
		return (tNUMERIC_TYPE_NAME != null) ? tNUMERIC_TYPE_NAME : (tNUMERIC_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMERIC_TYPE_NAME"));
	} 

	//terminal INT_TYPE_NAME:
	//	SIGN_INT_TYPE_NAME | UNSIGN_INT_TYPE_NAME;
	public TerminalRule getINT_TYPE_NAMERule() {
		return (tINT_TYPE_NAME != null) ? tINT_TYPE_NAME : (tINT_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT_TYPE_NAME"));
	} 

	//terminal SIGN_INT_TYPE_NAME:
	//	"SINT" | "INT" | "DINT" | "LINT";
	public TerminalRule getSIGN_INT_TYPE_NAMERule() {
		return (tSIGN_INT_TYPE_NAME != null) ? tSIGN_INT_TYPE_NAME : (tSIGN_INT_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SIGN_INT_TYPE_NAME"));
	} 

	//terminal UNSIGN_INT_TYPE_NAME:
	//	"USINT" | "UINT" | "UDINT" | "ULINT";
	public TerminalRule getUNSIGN_INT_TYPE_NAMERule() {
		return (tUNSIGN_INT_TYPE_NAME != null) ? tUNSIGN_INT_TYPE_NAME : (tUNSIGN_INT_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UNSIGN_INT_TYPE_NAME"));
	} 

	//terminal REAL_TYPE_NAME:
	//	"REAL" | "LREAL";
	public TerminalRule getREAL_TYPE_NAMERule() {
		return (tREAL_TYPE_NAME != null) ? tREAL_TYPE_NAME : (tREAL_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REAL_TYPE_NAME"));
	} 

	//terminal STRING_TYPE_NAME:
	//	"STRING" ("[" UNSIGNED_INT "]")? | "WSTRING" ("[" UNSIGNED_INT "]")? | "CHAR" | "WCHAR";
	public TerminalRule getSTRING_TYPE_NAMERule() {
		return (tSTRING_TYPE_NAME != null) ? tSTRING_TYPE_NAME : (tSTRING_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING_TYPE_NAME"));
	} 

	//terminal TIME_TYPE_NAME:
	//	"TIME" | "LTIME";
	public TerminalRule getTIME_TYPE_NAMERule() {
		return (tTIME_TYPE_NAME != null) ? tTIME_TYPE_NAME : (tTIME_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TIME_TYPE_NAME"));
	} 

	//terminal DATE_TYPE_NAME:
	//	"DATE" | "LDATE";
	public TerminalRule getDATE_TYPE_NAMERule() {
		return (tDATE_TYPE_NAME != null) ? tDATE_TYPE_NAME : (tDATE_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DATE_TYPE_NAME"));
	} 

	//terminal TOD_TYPE_NAME:
	//	"TIME_OF_DAY" | "TOD" | "LTOD";
	public TerminalRule getTOD_TYPE_NAMERule() {
		return (tTOD_TYPE_NAME != null) ? tTOD_TYPE_NAME : (tTOD_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TOD_TYPE_NAME"));
	} 

	//terminal DT_TYPE_NAME:
	//	"DATE_AND_TIME" | "DT" | "LDT";
	public TerminalRule getDT_TYPE_NAMERule() {
		return (tDT_TYPE_NAME != null) ? tDT_TYPE_NAME : (tDT_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DT_TYPE_NAME"));
	} 

	//terminal BIT_STR_TYPE_NAME:
	//	BOOL_TYPE_NAME | MULTIBITS_TYPE_NAME;
	public TerminalRule getBIT_STR_TYPE_NAMERule() {
		return (tBIT_STR_TYPE_NAME != null) ? tBIT_STR_TYPE_NAME : (tBIT_STR_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BIT_STR_TYPE_NAME"));
	} 

	//terminal BOOL_TYPE_NAME:
	//	"BOOL";
	public TerminalRule getBOOL_TYPE_NAMERule() {
		return (tBOOL_TYPE_NAME != null) ? tBOOL_TYPE_NAME : (tBOOL_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOL_TYPE_NAME"));
	} 

	//terminal MULTIBITS_TYPE_NAME:
	//	"BYTE" | "WORD" | "DWORD" | "LWORD";
	public TerminalRule getMULTIBITS_TYPE_NAMERule() {
		return (tMULTIBITS_TYPE_NAME != null) ? tMULTIBITS_TYPE_NAME : (tMULTIBITS_TYPE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MULTIBITS_TYPE_NAME"));
	} 

	//// Table 11 - Declaration of user-defined data types and initialization
	////Derived_Type_Access : Single_Elem_Type_Access | Array_Type_Access | Struct_Type_Access | String_Type_Access | Class_Type_Access | Ref_Type_Access | Interface_Type_Access;
	//String_Type_Access:
	//	(Namespace_Name DOT)* STRING_TYPE_NAME;
	public String_Type_AccessElements getString_Type_AccessAccess() {
		return (pString_Type_Access != null) ? pString_Type_Access : (pString_Type_Access = new String_Type_AccessElements());
	}
	
	public ParserRule getString_Type_AccessRule() {
		return getString_Type_AccessAccess().getRule();
	}

	//Single_Elem_Type_Access:
	//	Simple_Type_Access | Subrange_Type_Access | Enum_Type_Access;
	public Single_Elem_Type_AccessElements getSingle_Elem_Type_AccessAccess() {
		return (pSingle_Elem_Type_Access != null) ? pSingle_Elem_Type_Access : (pSingle_Elem_Type_Access = new Single_Elem_Type_AccessElements());
	}
	
	public ParserRule getSingle_Elem_Type_AccessRule() {
		return getSingle_Elem_Type_AccessAccess().getRule();
	}

	//Simple_Type_Access:
	//	(Namespace_Name DOT)* Simple_Type_Name;
	public Simple_Type_AccessElements getSimple_Type_AccessAccess() {
		return (pSimple_Type_Access != null) ? pSimple_Type_Access : (pSimple_Type_Access = new Simple_Type_AccessElements());
	}
	
	public ParserRule getSimple_Type_AccessRule() {
		return getSimple_Type_AccessAccess().getRule();
	}

	//Subrange_Type_Access:
	//	(Namespace_Name DOT)* Subrange_Type_Name;
	public Subrange_Type_AccessElements getSubrange_Type_AccessAccess() {
		return (pSubrange_Type_Access != null) ? pSubrange_Type_Access : (pSubrange_Type_Access = new Subrange_Type_AccessElements());
	}
	
	public ParserRule getSubrange_Type_AccessRule() {
		return getSubrange_Type_AccessAccess().getRule();
	}

	//Enum_Type_Access:
	//	(Namespace_Name DOT)* Enum_Type_Name;
	public Enum_Type_AccessElements getEnum_Type_AccessAccess() {
		return (pEnum_Type_Access != null) ? pEnum_Type_Access : (pEnum_Type_Access = new Enum_Type_AccessElements());
	}
	
	public ParserRule getEnum_Type_AccessRule() {
		return getEnum_Type_AccessAccess().getRule();
	}

	//Array_Type_Access:
	//	(Namespace_Name DOT)* Array_Type_Name;
	public Array_Type_AccessElements getArray_Type_AccessAccess() {
		return (pArray_Type_Access != null) ? pArray_Type_Access : (pArray_Type_Access = new Array_Type_AccessElements());
	}
	
	public ParserRule getArray_Type_AccessRule() {
		return getArray_Type_AccessAccess().getRule();
	}

	//Struct_Type_Access:
	//	(Namespace_Name DOT)* Struct_Type_Name;
	public Struct_Type_AccessElements getStruct_Type_AccessAccess() {
		return (pStruct_Type_Access != null) ? pStruct_Type_Access : (pStruct_Type_Access = new Struct_Type_AccessElements());
	}
	
	public ParserRule getStruct_Type_AccessRule() {
		return getStruct_Type_AccessAccess().getRule();
	}

	//Simple_Type_Name returns EString:
	//	IDENTIFIER;
	public Simple_Type_NameElements getSimple_Type_NameAccess() {
		return (pSimple_Type_Name != null) ? pSimple_Type_Name : (pSimple_Type_Name = new Simple_Type_NameElements());
	}
	
	public ParserRule getSimple_Type_NameRule() {
		return getSimple_Type_NameAccess().getRule();
	}

	//Subrange_Type_Name returns EString:
	//	IDENTIFIER;
	public Subrange_Type_NameElements getSubrange_Type_NameAccess() {
		return (pSubrange_Type_Name != null) ? pSubrange_Type_Name : (pSubrange_Type_Name = new Subrange_Type_NameElements());
	}
	
	public ParserRule getSubrange_Type_NameRule() {
		return getSubrange_Type_NameAccess().getRule();
	}

	//Enum_Type_Name returns EString:
	//	IDENTIFIER;
	public Enum_Type_NameElements getEnum_Type_NameAccess() {
		return (pEnum_Type_Name != null) ? pEnum_Type_Name : (pEnum_Type_Name = new Enum_Type_NameElements());
	}
	
	public ParserRule getEnum_Type_NameRule() {
		return getEnum_Type_NameAccess().getRule();
	}

	//Array_Type_Name returns EString:
	//	IDENTIFIER;
	public Array_Type_NameElements getArray_Type_NameAccess() {
		return (pArray_Type_Name != null) ? pArray_Type_Name : (pArray_Type_Name = new Array_Type_NameElements());
	}
	
	public ParserRule getArray_Type_NameRule() {
		return getArray_Type_NameAccess().getRule();
	}

	//Struct_Type_Name returns EString:
	//	IDENTIFIER;
	public Struct_Type_NameElements getStruct_Type_NameAccess() {
		return (pStruct_Type_Name != null) ? pStruct_Type_Name : (pStruct_Type_Name = new Struct_Type_NameElements());
	}
	
	public ParserRule getStruct_Type_NameRule() {
		return getStruct_Type_NameAccess().getRule();
	}

	////
	////Data_Type_Decl : 'TYPE' ( typeDeclarations+=Type_Decl ';' )+ 'END_TYPE';
	////Struct_Decl :'STRUCT' (overlap?='OVERLAP')? ( elements+=Struct_Elem_Decl ';' )+ 'END_STRUCT';
	////
	////Type_Decl : Simple_Type_Decl | Subrange_Type_Decl | Enum_Type_Decl | Array_Type_Decl | Struct_Type_Decl | Str_Type_Decl | Ref_Type_Decl;
	////Simple_Type_Decl : type=Simple_Type_Name ':' initialization=Simple_Spec_Init;
	////Subrange_Type_Decl : type=Subrange_Type_Name ':' initialization=Subrange_Spec_Init;
	////Enum_Type_Decl : type=Enum_Type_Name ':' initialization=( Elem_Named_Spec | Enum_Spec_Init );
	////Array_Type_Decl : type=Array_Type_Name ':' initialization=Array_Spec_Init;
	////Struct_Type_Decl : type=Struct_Type_Name ':' initialization=Struct_Spec;
	////Struct_Elem_Decl : type=Struct_Elem_Name ( location=Located_At access=Multibit_Part_Access ? )? ':' initialization=( Simple_Spec_Init | Subrange_Spec_Init | Enum_Spec_Init | Array_Spec_Init | Struct_Spec_Init );
	////Str_Type_Decl : type=STRING_TYPE_NAME ':' initialization=STRING_TYPE_NAME ( ASSIGNMENT initialValue=CHAR_STR )?;
	////
	////Simple_Spec : type=(ELEM_TYPE_NAME | Simple_Type_Access);
	////Subrange_Spec : (type=INT_TYPE_NAME '(' range=Subrange ')') | (refRange=Subrange_Type_Access);
	////Enum_Value_Spec : type=IDENTIFIER ( ASSIGNMENT ( initialValue=INT_LITERAL | initialization=Constant_Expr ) )?;
	////Elem_Named_Spec : type=ELEM_TYPE_NAME ? initialization=Named_Spec_Init;
	////Array_Spec : type=(Array_Type_Access | 'ARRAY') '[' ranges+=Subrange ( ',' ranges+=Subrange )* ']' 'OF' refDataType=Data_Type_Access;
	////Struct_Spec : Struct_Decl | Struct_Spec_Init;
	////
	////Simple_Spec_Init : type=Simple_Spec ( ASSIGNMENT initialValue=Constant_Expr )?;
	////Subrange_Spec_Init : type=Subrange_Spec ( ASSIGNMENT initialValue=SIGNED_INT )?;
	////Subrange : lowBound=Constant_Expr '..' upBound=Constant_Expr;
	////Named_Spec_Init : '(' initialValues+=Enum_Value_Spec ( ',' initialValues+=Enum_Value_Spec )* ')' ( ASSIGNMENT value=Enum_Value )?;
	////
	////Enum_Spec_Init : ( ( '(' enumItem+=IDENTIFIER ( ',' enumItem+=IDENTIFIER )* ')' ) | refEnum=Enum_Type_Access ) ( ASSIGNMENT value=Enum_Value )?;
	////Enum_Value : ( type=Enum_Type_Name '#' )? value=IDENTIFIER;
	////
	////Array_Spec_Init : type=Array_Spec ( ASSIGNMENT initialValue=Array_Init )?;
	////Array_Init : '[' initialValues+=Array_Elem_Init ( ',' initialValues+=Array_Elem_Init )* ']';
	////Array_Elem_Init : (initialization=Array_Elem_Init_Value | initialValue=UNSIGNED_INT) '(' bound=Array_Elem_Init_Value ? ')';
	////Array_Elem_Init_Value : Constant_Expr | Enum_Value | Struct_Init | Array_Init;
	////
	////Struct_Spec_Init : type=Struct_Type_Access ( ASSIGNMENT initialValue=Struct_Init )?;
	////Struct_Elem_Name returns EString : IDENTIFIER;
	////Struct_Init : '(' elementInits+=Struct_Elem_Init ( ',' elementInits+=Struct_Elem_Init )* ')';
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: uncomment Constant_Expr below ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Struct_Elem_Init : type=Struct_Elem_Name ASSIGNMENT initialization=( / * Constant_Expr | * / Enum_Value | Array_Init | Ref_Value | Struct_Init );
	////
	////
	////// Table 16 - Directly represented variables
	////Direct_Variable : '%' locationPrefix=( 'I' | 'Q' | 'M' ) sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' )? bitIndexes+=UNSIGNED_INT ( DOT bitIndexes+=UNSIGNED_INT )*;
	////
	////
	////// Table 12 - Reference operations
	////Ref_Type_Decl : type=Ref_Type_Name ':' initialization=Ref_Spec_Init;
	////Ref_Spec_Init : type=Ref_Spec ( ASSIGNMENT initialValue=Ref_Value )?;
	////Ref_Spec : 'REF_TO' + reference=Data_Type_Access;
	////Ref_Type_Name returns EString : IDENTIFIER;
	////Ref_Type_Access : ( Namespace_Name DOT )* Ref_Type_Name;
	////Ref_Name returns EString : IDENTIFIER;
	////Ref_Value : {Ref_Value} (reference=Ref_Addr | 'NULL');
	////Ref_Addr : 'REF' '(' ( referencedVar=Symbolic_Variable | referencedName=(FB_Instance_Name | Class_Instance_Name ) ) ')';
	////Ref_Assign : type=Ref_Name ASSIGNMENT ( initialValue=Ref_Name | initialization=(Ref_Deref | Ref_Value) );
	////Ref_Deref : name=Ref_Name '^' +;
	////
	////
	////// Table 13 - Declaration of variables/Table 14 – Initialization of variables
	////Variable : Direct_Variable | Symbolic_Variable;
	////Symbolic_Variable : (( qualifiers+='THIS' DOT ) | ( qualifiers+=Namespace_Name DOT )+)? variable=( Var_Access | Multi_Elem_Var );
	////Var_Access : {Var_Access} (variable=Variable_Name | reference=Ref_Deref);
	////Variable_Name returns EString : IDENTIFIER;
	////Multi_Elem_Var : access=Var_Access elements+=( Subscript_List | Struct_Variable )+;
	////Subscript_List : '[' item+=Subscript ( ',' item+=Subscript )* ']';
	////Subscript : Expression;
	////Struct_Variable : DOT Struct_Elem_Select;
	////Struct_Elem_Select : Var_Access;
	////Input_Decls : {Input_Decls} 'VAR_INPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( inputs+=Input_Decl ';' )* 'END_VAR';
	////Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
	////Edge_Decl : variables=Variable_List ':' BOOL_TYPE_NAME edgeType=( 'R_EDGE' | 'F_EDGE' );
	////Var_Decl_Init : variables=Variable_List ':' initialization=(( Simple_Spec_Init | Str_Var_Decl | Ref_Spec_Init ) | Array_Var_Decl_Init | Struct_Var_Decl_Init | FB_Decl_Init | Interface_Spec_Init);
	////Ref_Var_Decl : variables=Variable_List ':' initialization=Ref_Spec;
	////Interface_Var_Decl : variables=Variable_List ':' initialization=Interface_Type_Access;
	////Variable_List : variables+=Variable_Name ( ',' variables+=Variable_Name )*;
	////Array_Var_Decl_Init : variables=Variable_List ':' initialization=Array_Spec_Init;
	////Array_Conformand : 'ARRAY' '[' '*' ( ',' '*' )* ']' 'OF' dataType=Data_Type_Access;
	////Array_Conform_Decl : variables=Variable_List ':' conformand=Array_Conformand;
	////Struct_Var_Decl_Init : variables=Variable_List ':' initialization=Struct_Spec_Init;
	////FB_Decl_No_Init : (names+=FB_Name ( ',' names+=FB_Name )*) ':' type=FB_Type_Access;
	////FB_Decl_Init : fb=FB_Decl_No_Init ( ASSIGNMENT initialization=Struct_Init )?;
	////FB_Name returns EString : IDENTIFIER;
	////FB_Instance_Name : ( Namespace_Name DOT )* FB_Name '^' *;
	////Output_Decls : {Output_Decls} 'VAR_OUTPUT' retainType=( 'RETAIN' | 'NON_RETAIN' )? ( outputs+=Output_Decl ';' )* 
	////	'END_VAR';
	////Output_Decl : Var_Decl_Init | Array_Conform_Decl;
	////In_Out_Decls : {In_Out_Decls} 'VAR_IN_OUT' ( inouts+=In_Out_Var_Decl ';' )* 
	////	'END_VAR';
	////In_Out_Var_Decl : Var_Decl | Array_Conform_Decl | FB_Decl_No_Init;
	////Var_Decl : variables=Variable_List ':' initialization=( Simple_Spec | Str_Var_Decl | Array_Var_Decl | Struct_Var_Decl );
	////Array_Var_Decl : variables=Variable_List ':' initialization=Array_Spec;
	////Struct_Var_Decl : variables=Variable_List ':' initialization=Struct_Type_Access;
	////Var_Decls : {Var_Decls} 'VAR' (constant?='CONSTANT' ?) access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
	////Retain_Var_Decls : {Retain_Var_Decls} 'VAR' 'RETAIN' access=Access_Spec? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
	////Loc_Var_Decls : {Loc_Var_Decls} 'VAR' modifier=( 'CONSTANT' | 'RETAIN' | 'NON_RETAIN' )? ( variables+=Loc_Var_Decl ';' )* 'END_VAR';
	////Loc_Var_Decl : name=Variable_Name ? location=Located_At ':' initialization=Loc_Var_Spec_Init;
	////Temp_Var_Decls : {Temp_Var_Decls} 'VAR_TEMP' ( variables+=( Var_Decl | Ref_Var_Decl | Interface_Var_Decl ) ';' )* 'END_VAR';
	////External_Var_Decls : {External_Var_Decls} 'VAR_EXTERNAL' (constant?='Constant' ?) ( variables+=External_Decl ';' )* 'END_VAR';
	////External_Decl : name=Global_Var_Name ':' ( initialization=(Simple_Spec | Array_Spec) | type=(Struct_Type_Access | FB_Type_Access | Ref_Type_Access ));
	////Global_Var_Name returns EString : IDENTIFIER;
	////Global_Var_Decls : {Global_Var_Decls} 'VAR_GLOBAL' modifier=( 'CONSTANT' | 'RETAIN' )? ( variables+=Global_Var_Decl ';' )* 'END_VAR';
	////Global_Var_Decl : name=Global_Var_Spec ':' ( initialization=Loc_Var_Spec_Init | type=FB_Type_Access );
	////Global_Var_Spec : ( variables+=Global_Var_Name ( ',' variables+=Global_Var_Name )* ) | ( variables+=Global_Var_Name location=Located_At );
	////Loc_Var_Spec_Init : Simple_Spec_Init | Array_Spec_Init | Struct_Spec_Init | S_Byte_Str_Spec | D_Byte_Str_Spec;
	////Located_At : 'AT' Direct_Variable;
	////Str_Var_Decl : S_Byte_Str_Var_Decl | D_Byte_Str_Var_Decl;
	////S_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=S_Byte_Str_Spec;
	////S_Byte_Str_Spec : {S_Byte_Str_Spec} 'STRING' ( '[' bound=UNSIGNED_INT ']' )? ( ASSIGNMENT initialValue=S_BYTE_CHAR_STR )?;
	////D_Byte_Str_Var_Decl : variables=Variable_List ':' initialization=D_Byte_Str_Spec;
	////D_Byte_Str_Spec : {D_Byte_Str_Spec} 'WSTRING' ( '[' bound=UNSIGNED_INT ']' )? ( ASSIGNMENT initialValue=D_BYTE_CHAR_STR )?;
	////Loc_Partly_Var_Decl : {Loc_Partly_Var_Decl} 'VAR' modifier=( 'RETAIN' | 'NON_RETAIN' )? variables+=Loc_Partly_Var * 'END_VAR';
	////Loc_Partly_Var : name=Variable_Name 'AT' '%' locationPrefix=( 'I' | 'Q' | 'M' ) '*' ':' initialization=Var_Spec ';';
	////Var_Spec : Simple_Spec | Array_Spec | Struct_Type_Access | StringVar_Spec;
	////StringVar_Spec: type=( 'STRING' | 'WSTRING' ) ( '[' bound=UNSIGNED_INT ']' )?;
	////
	////// Table 19 - Function declaration
	////Func_Name : Std_Func_Name | Derived_Func_Name;
	////Func_Access : ( Namespace_Name DOT )* Func_Name;
	////Std_Func_Name : 'TRUNC' | 'ABS' | 'SQRT' | 'LN' | 'LOG' | 'EXP'
	////| 'SIN' | 'COS' | 'TAN' | 'ASIN' | 'ACOS' | 'ATAN' | 'ATAN2 '
	////| 'ADD' | 'SUB' | 'MUL' | 'DIV' | 'MOD' | 'EXPT' | 'MOVE '
	////| 'SHL' | 'SHR' | 'ROL' | 'ROR'
	////| 'AND' | 'OR'  | 'XOR' | 'NOT'
	////| 'SEL' | 'MAX' | 'MIN' | 'LIMIT' | 'MUX '
	////| 'GT' | 'GE' | 'EQ' | 'LE' | 'LT' | 'NE'
	////| 'LEN' | 'LEFT' | 'RIGHT' | 'MID' | 'CONCAT' | 'INSERT' | 'DELETE' | 'REPLACE' | 'FIND';
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: complete list above ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Derived_Func_Name returns EString : IDENTIFIER;
	////Func_Decl : 'FUNCTION' name=Derived_Func_Name ( ':' returnType=Data_Type_Access )? usings+=Using_Directive* ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
	////		'END_FUNCTION';
	////IO_Var_Decls : Input_Decls | Output_Decls | In_Out_Decls;
	////Func_Var_Decls : External_Var_Decls | Var_Decls;
	////
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: other languages on list below ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Func_Body : / *Ladder_Diagram | FB_Diagram | Instruction_List |* / Stmt_List;// | Other_Languages;
	////
	////
	////// Table 40 – Function block type declaration
	////
	////// Table 41 - Function block instance declaration
	////FB_Type_Name : Std_FB_Name | Derived_FB_Name;
	////FB_Type_Access : ( Namespace_Name DOT )* FB_Type_Name;
	////Std_FB_Name : 'SR' | 'RS' | 'R_TRIG' | 'F_TRIG' | 'CTU'| 'CTD' | 'CTUD' | 'TP' | 'TON' | 'TOF';
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: complete list above ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Derived_FB_Name returns EString : IDENTIFIER;
	////FB_Decl : 'FUNCTION_BLOCK' modifier=( 'FINAL' | 'ABSTRACT' )? name=Derived_FB_Name usings+=Using_Directive* ( 'EXTENDS' extends=( FB_Type_Access | Class_Type_Access ) )?
	////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( ios+=FB_IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls )*
	////	( methods+=Method_Decl )* body=FB_Body ? 
	////	'END_FUNCTION_BLOCK';
	////FB_IO_Var_Decls : FB_Input_Decls | FB_Output_Decls | In_Out_Decls;
	////FB_Input_Decls : {FB_Input_Decls} 'VAR_INPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Input_Decl ';' )* 'END_VAR';
	////FB_Input_Decl : Var_Decl_Init | Edge_Decl | Array_Conform_Decl;
	////FB_Output_Decls : {FB_Output_Decls} 'VAR_OUTPUT' modifier=( 'RETAIN' | 'NON_RETAIN' )? ( variables+=FB_Output_Decl ';' )* 'END_VAR';
	////FB_Output_Decl : Var_Decl_Init | Array_Conform_Decl;
	////Other_Var_Decls : Retain_Var_Decls | No_Retain_Var_Decls | Loc_Partly_Var_Decl;
	////No_Retain_Var_Decls : {No_Retain_Var_Decls} 'VAR' 'NON_RETAIN' access=Access_Spec ? ( variables+=Var_Decl_Init ';' )* 'END_VAR';
	////
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: other languages on list below ^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////FB_Body : Stmt_List; //| SFC | Ladder_Diagram | FB_Diagram | Instruction_List | Other_Languages;
	////Method_Decl : 'METHOD' access=Access_Spec type=( 'FINAL' | 'ABSTRACT' )? override?='OVERRIDE'?
	////	name=Method_Name ( ':' returnType=Data_Type_Access )? ( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls )* body=Func_Body 
	////	'END_METHOD';
	////Method_Name returns EString : IDENTIFIER;
	////
	////// Table 48 - Class
	////
	////// Table 50 Textual call of methods – Formal and non-formal parameter list
	////Class_Decl : 'CLASS' modifier=( 'FINAL' | 'ABSTRACT' )? name=Class_Type_Name usings+=Using_Directive* ( 'EXTENDS' extends=Class_Type_Access )? 
	////	( 'IMPLEMENTS' implements=Interface_Name_List )? ( variables+=Func_Var_Decls | others+=Other_Var_Decls )* ( methods+=Method_Decl )* 
	////	'END_CLASS';
	////Class_Type_Name returns EString : IDENTIFIER;
	////Class_Type_Access : ( Namespace_Name DOT )* Class_Type_Name;
	////Class_Name returns EString : IDENTIFIER;
	////Class_Instance_Name : ( Namespace_Name DOT )* Class_Name '^' *;
	////Interface_Decl : 'INTERFACE' name=Interface_Type_Name usings+=Using_Directive* 
	////	( 'EXTENDS' extends+=Interface_Name_List )? 
	////	methods+=Method_Prototype* 
	////	'END_INTERFACE';
	////Method_Prototype : 'METHOD' name=Method_Name ( ':' returnType=Data_Type_Access )? ios+=IO_Var_Decls* 
	////	'END_METHOD';
	////Interface_Spec_Init : variables=Variable_List ( ASSIGNMENT initialization=Interface_Value )?;
	////Interface_Value : ((variable=Symbolic_Variable) | variableName=(FB_Instance_Name | Class_Instance_Name | 'NULL'));
	////Interface_Name_List : interfaces+=Interface_Type_Access ( ',' interfaces+=Interface_Type_Access )*;
	////Interface_Type_Name returns EString : IDENTIFIER;
	////Interface_Type_Access : ( Namespace_Name DOT )* Interface_Type_Name;
	////Interface_Name returns EString : IDENTIFIER;
	////Access_Spec : 'PUBLIC' | 'PROTECTED' | 'PRIVATE' | 'INTERNAL';
	////
	////// Table 47 - Program declaration
	////Prog_Decl : 'PROGRAM' name=Prog_Type_Name
	////	( ios+=IO_Var_Decls | variables+=Func_Var_Decls | temps+=Temp_Var_Decls | others+=Other_Var_Decls | locals+=Loc_Var_Decls | acesses+=Prog_Access_Decls )* 
	////body=FB_Body 'END_PROGRAM';
	////Prog_Type_Name returns EString : IDENTIFIER;
	////Prog_Type_Access : ( Namespace_Name DOT )* Prog_Type_Name;
	////Prog_Access_Decls : {Prog_Access_Decls} 'VAR_ACCESS' ( accesses+=Prog_Access_Decl ';' )* 'END_VAR';
	////Prog_Access_Decl : name=Access_Name ':' variable=Symbolic_Variable access=Multibit_Part_Access? ':' dataType=Data_Type_Access direction=Access_Direction?;
	////
	////// Table 62 - Configuration and resource declaration
	//////Config_Name returns EString : IDENTIFIER;
	//////Resource_Type_Name returns EString : IDENTIFIER;
	//////Config_Decl : 'CONFIGURATION' Config_Name Global_Var_Decls ?
	//////( Single_Resource_Decl | Resource_Decl + ) Access_Decls ? Config_Init ?
	//////'END_CONFIGURATION';
	//////Resource_Decl : 'RESOURCE' Resource_Name 'ON' Resource_Type_Name
	//////Global_Var_Decls ? Single_Resource_Decl
	//////'END_RESOURCE';
	//////Single_Resource_Decl : ( Task_Config ';' )* ( Prog_Config ';' )+;
	//////Resource_Name returns EString : IDENTIFIER;
	//////Access_Decls : 'VAR_ACCESS' ( Access_Decl ';' )* 'END_VAR';
	//////Access_Decl : Access_Name ':' Access_Path ':' Data_Type_Access Access_Direction ?;
	//////Access_Path : ( Resource_Name DOT )? Direct_Variable
	//////| ( Resource_Name DOT )? ( Prog_Name DOT )?
	//////( ( FB_Instance_Name | Class_Instance_Name ) DOT )* Symbolic_Variable;
	//////Global_Var_Access : ( Resource_Name DOT )? Global_Var_Name ( DOT Struct_Elem_Name )?;
	////Access_Name returns EString : IDENTIFIER;
	//////Prog_Output_Access : Prog_Name DOT Symbolic_Variable;
	//////Prog_Name returns EString : IDENTIFIER;
	////Access_Direction : 'READ_WRITE' | 'READ_ONLY';
	//////Task_Config : 'TASK' Task_Name Task_Init;
	//////Task_Name returns EString : IDENTIFIER;
	//////Task_Init : '(' ( 'SINGLE' ASSIGNMENT Data_Source ',' )?
	//////( 'INTERVAL' ASSIGNMENT Data_Source ',' )?
	//////'PRIORITY' ASSIGNMENT UNSIGNED_INT ')';
	//////Data_Source : Constant | Global_Var_Access | Prog_Output_Access | Direct_Variable;
	//////Prog_Config : 'PROGRAM' ( 'RETAIN' | 'NON_RETAIN' )? Prog_Name ( 'WITH' Task_Name )? ':'
	//////Prog_Type_Access ( '(' Prog_Conf_Elems ')' )?;
	//////Prog_Conf_Elems : Prog_Conf_Elem ( ',' Prog_Conf_Elem )*;
	//////Prog_Conf_Elem : FB_Task | Prog_Cnxn;
	//////FB_Task : FB_Instance_Name 'WITH' Task_Name;
	//////Prog_Cnxn : Symbolic_Variable ASSIGNMENT Prog_Data_Source | Symbolic_Variable '=>' Data_Sink;
	//////Prog_Data_Source : Constant | Enum_Value | Global_Var_Access | Direct_Variable;
	//////Data_Sink : Global_Var_Access | Direct_Variable;
	//////Config_Init : 'VAR_CONFIG' ( Config_Inst_Init ';' )* 'END_VAR';
	//////Config_Inst_Init : Resource_Name DOT Prog_Name DOT ( ( FB_Instance_Name | Class_Instance_Name ) DOT )*
	//////( Variable_Name Located_At ? ':' Loc_Var_Spec_Init
	//////| ( ( FB_Instance_Name ':' FB_Type_Access )
	//////| ( Class_Instance_Name ':' Class_Type_Access ) ) ASSIGNMENT Struct_Init );
	//////
	//////// Table 64 - Namespace
	//////Namespace_Decl : 'NAMESPACE' 'INTERNAL' ? Namespace_H_Name Using_Directive * Namespace_Elements
	//////'END_NAMESPACE';
	//////Namespace_Elements : ( Data_Type_Decl | Func_Decl | FB_Decl
	//////| Class_Decl | Interface_Decl | Namespace_Decl )+;
	////Namespace_H_Name : qualifier+=Namespace_Name ( DOT qualifier+=Namespace_Name )*;
	////Using_Directive : 'USING' namespaces+=Namespace_H_Name ( ',' namespaces+=Namespace_H_Name )* ';';
	//////POU_Decl : Using_Directive *
	//////( Global_Var_Decls | Data_Type_Decl | Access_Decls
	//////| Func_Decl | FB_Decl | Class_Decl | Interface_Decl
	//////| Namespace_Decl )+;
	//////
	////
	////// Table 71 - 72 - Language Structured Text (ST)
	////Expression returns Expression: Xor_Expr ({Expression.left=current} operator='OR' right=Xor_Expr )*;
	////// a constant expression must evaluate to a constant value at compile time
	////Constant_Expr : Expression;
	////Xor_Expr returns Expression: And_Expr ({Xor_Expr.left=current} operator='XOR' right=And_Expr )*;
	////And_Expr returns Expression: Compare_Expr ({And_Expr.left=current} operator=( '&' | 'AND' ) right=Compare_Expr )*;
	////Compare_Expr returns Expression: Equ_Expr ({Compare_Expr.left=current} operator=( '=' | '<>' ) right=Equ_Expr )*;
	////Equ_Expr returns Expression: Add_Expr ({Equ_Expr.left=current} operator=( '<' | '>' | '<=' | '>=' ) right=Add_Expr )*;
	////Add_Expr returns Expression: Term ({Add_Expr.left=current} operator=( '+' | '-' ) right=Term )*;
	////Term returns Expression: Power_Expr ({Term.left=current} operator=('*' | '/' | 'MOD') right=Power_Expr )*;
	////Power_Expr returns Expression: Unary_Expr ({Power_Expr.left=current} operator='**' right=Unary_Expr )*;
	////Unary_Expr returns Expression: operator=('-' | '+' | 'NOT')? expression=Primary_Expr;
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below Func_Call |  Ref_Value | '(' Expression ')'^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Primary_Expr returns Expression: {Expression} Constant | Enum_Value | Variable_Access / * | Func_Call |  Ref_Value | '(' Expression ')' * /;
	////
	////Variable_Access : variable=Variable access=Multibit_Part_Access ?;
	////Multibit_Part_Access : DOT ( accessSize=UNSIGNED_INT | accessSizeInfo=Size_Info );
	////Size_Info : '%' sizePrefix=( 'X' | 'B' | 'W' | 'D' | 'L' ) ? size=UNSIGNED_INT;
	////Func_Call : access=Func_Access '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
	////Stmt_List : {Stmt_List} ( statement+=Stmt ? ';' )*;
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below Assign_Stmt | Subprog_Ctrl_Stmt |^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Stmt : / * Assign_Stmt | Subprog_Ctrl_Stmt | * / Selection_Stmt | Iteration_Stmt;
	////Assign_Stmt : Variable_Assign_Stmt | Ref_Assign | Assignment_Attempt;
	////Variable_Assign_Stmt : left=Variable ASSIGNMENT right=Expression;
	////Assignment_Attempt : ( leftName=Ref_Name | leftReference=Ref_Deref ) '?=' ( rightName=Ref_Name | rightReference=(Ref_Deref | Ref_Value) );
	////Invocation : method=( FB_Instance_Name | Method_Name | 'THIS' | Qualified_Method_Call ) '(' ( parameters+=Param_Assign ( ',' parameters+=Param_Assign )* )? ')';
	////Qualified_Method_Call : ( ( 'THIS' DOT )? ( ( ( FB_Instance_Name | Class_Instance_Name ) DOT )+ ) Method_Name );
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Subprog_Ctrl_Stmt : / * Func_Call | Invocation | * / Super_Invocation | Return;
	////Sub_Invocation: Super_Invocation | Return;
	////Super_Invocation : 'SUPER' '(' ')';
	////Return : 'RETURN';
	////Param_Assign : Named_Value | Ref_Assign | Linked_Value;
	////Named_Value : ( name=Variable_Name ASSIGNMENT )? value=Expression;
	////Linked_Value : (negated?='NOT')? name=Variable_Name '=>' value=Variable;
	////Selection_Stmt : IF_Stmt | Case_Stmt;
	////IF_Stmt : 'IF' condition=Expression 'THEN' statements=Stmt_List ( elseifs+=ELSEIF_Stmt )* ( else=ELSE_Stmt )? 'END_IF';
	////ELSEIF_Stmt : 'ELSIF' condition=Expression 'THEN' statements=Stmt_List;
	////ELSE_Stmt: 'ELSE' statements=Stmt_List;
	////Case_Stmt : 'CASE' expression=Expression 'OF' cases+=Case_Selection + ( 'ELSE' defaultStatements=Stmt_List )? 'END_CASE';
	////Case_Selection : values=Case_List ':' statements=Stmt_List;
	////Case_List : caseValues+=Case_List_Elem ( ',' caseValues+=Case_List_Elem )*;
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// ^ TODO: Uncomment in line below Func_Call | Invocation |^
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////// *******************************************************
	////Case_List_Elem : Subrange / *| Constant_Expr* /;
	////Iteration_Stmt : For_Stmt | While_Stmt | Repeat_Stmt | Exit_Stmt | Continue_Stmt;
	////Exit_Stmt : {Exit_Stmt} 'EXIT';
	////Continue_Stmt : {Continue_Stmt} 'CONTINUE';
	////For_Stmt : 'FOR' variable=Control_Variable ASSIGNMENT bounds=For_List 'DO' statements=Stmt_List 'END_FOR';
	////Control_Variable returns EString : IDENTIFIER;
	////For_List : lowBound=Expression 'TO' upBound=Expression ( 'BY' step=Expression )?;
	////While_Stmt : 'WHILE' condition=Expression 'DO' statements=Stmt_List 'END_WHILE';
	////Repeat_Stmt : 'REPEAT' statements=Stmt_List 'UNTIL' condition=Expression 'END_REPEAT'; Namespace_Name returns EString:
	//	IDENTIFIER;
	public Namespace_NameElements getNamespace_NameAccess() {
		return (pNamespace_Name != null) ? pNamespace_Name : (pNamespace_Name = new Namespace_NameElements());
	}
	
	public ParserRule getNamespace_NameRule() {
		return getNamespace_NameAccess().getRule();
	}
}
